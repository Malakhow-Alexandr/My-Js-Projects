{"mappings":"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","sources":["node_modules/bootstrap.native/dist/bootstrap-native.esm.js","src/js/17-modal-spam.js"],"sourcesContent":["/*!\n  * Native JavaScript for Bootstrap v4.2.0 (https://thednp.github.io/bootstrap.native/)\n  * Copyright 2015-2022 © dnp_theme\n  * Licensed under MIT (https://github.com/thednp/bootstrap.native/blob/master/LICENSE)\n  */\n/** @type {Record<string, any>} */\nconst EventRegistry = {};\n\n/**\n * The global event listener.\n *\n * @type {EventListener}\n * @this {EventTarget}\n */\nfunction globalListener(e) {\n  const that = this;\n  const { type } = e;\n\n  [...EventRegistry[type]].forEach((elementsMap) => {\n    const [element, listenersMap] = elementsMap;\n    /* istanbul ignore else */\n    if (element === that) {\n      [...listenersMap].forEach((listenerMap) => {\n        const [listener, options] = listenerMap;\n        listener.apply(element, [e]);\n\n        if (options && options.once) {\n          removeListener(element, type, listener, options);\n        }\n      });\n    }\n  });\n}\n\n/**\n * Register a new listener with its options and attach the `globalListener`\n * to the target if this is the first listener.\n *\n * @type {Listener.ListenerAction<EventTarget>}\n */\nconst addListener = (element, eventType, listener, options) => {\n  // get element listeners first\n  if (!EventRegistry[eventType]) {\n    EventRegistry[eventType] = new Map();\n  }\n  const oneEventMap = EventRegistry[eventType];\n\n  if (!oneEventMap.has(element)) {\n    oneEventMap.set(element, new Map());\n  }\n  const oneElementMap = oneEventMap.get(element);\n\n  // get listeners size\n  const { size } = oneElementMap;\n\n  // register listener with its options\n  oneElementMap.set(listener, options);\n\n  // add listener last\n  if (!size) {\n    element.addEventListener(eventType, globalListener, options);\n  }\n};\n\n/**\n * Remove a listener from registry and detach the `globalListener`\n * if no listeners are found in the registry.\n *\n * @type {Listener.ListenerAction<EventTarget>}\n */\nconst removeListener = (element, eventType, listener, options) => {\n  // get listener first\n  const oneEventMap = EventRegistry[eventType];\n  const oneElementMap = oneEventMap && oneEventMap.get(element);\n  const savedOptions = oneElementMap && oneElementMap.get(listener);\n\n  // also recover initial options\n  const { options: eventOptions } = savedOptions !== undefined\n    ? savedOptions\n    : { options };\n\n  // unsubscribe second, remove from registry\n  if (oneElementMap && oneElementMap.has(listener)) oneElementMap.delete(listener);\n  if (oneEventMap && (!oneElementMap || !oneElementMap.size)) oneEventMap.delete(element);\n  if (!oneEventMap || !oneEventMap.size) delete EventRegistry[eventType];\n\n  // remove listener last\n  /* istanbul ignore else */\n  if (!oneElementMap || !oneElementMap.size) {\n    element.removeEventListener(eventType, globalListener, eventOptions);\n  }\n};\n\n/**\n * Advanced event listener based on subscribe / publish pattern.\n * @see https://www.patterns.dev/posts/classic-design-patterns/#observerpatternjavascript\n * @see https://gist.github.com/shystruk/d16c0ee7ac7d194da9644e5d740c8338#file-subpub-js\n * @see https://hackernoon.com/do-you-still-register-window-event-listeners-in-each-component-react-in-example-31a4b1f6f1c8\n */\nconst Listener = {\n  on: addListener,\n  off: removeListener,\n  globalListener,\n  registry: EventRegistry,\n};\n\n/**\n * A global namespace for `click` event.\n * @type {string}\n */\nconst mouseclickEvent = 'click';\n\n/**\n * A global namespace for 'transitionend' string.\n * @type {string}\n */\nconst transitionEndEvent = 'transitionend';\n\n/**\n * A global namespace for 'transitionDelay' string.\n * @type {string}\n */\nconst transitionDelay = 'transitionDelay';\n\n/**\n * A global namespace for `transitionProperty` string for modern browsers.\n *\n * @type {string}\n */\nconst transitionProperty = 'transitionProperty';\n\n/**\n * Shortcut for `window.getComputedStyle(element).propertyName`\n * static method.\n *\n * * If `element` parameter is not an `HTMLElement`, `getComputedStyle`\n * throws a `ReferenceError`.\n *\n * @param {HTMLElement} element target\n * @param {string} property the css property\n * @return {string} the css property value\n */\nfunction getElementStyle(element, property) {\n  const computedStyle = getComputedStyle(element);\n\n  // must use camelcase strings,\n  // or non-camelcase strings with `getPropertyValue`\n  return property.includes('--')\n    ? computedStyle.getPropertyValue(property)\n    : computedStyle[property];\n}\n\n/**\n * Utility to get the computed `transitionDelay`\n * from Element in miliseconds.\n *\n * @param {HTMLElement} element target\n * @return {number} the value in miliseconds\n */\nfunction getElementTransitionDelay(element) {\n  const propertyValue = getElementStyle(element, transitionProperty);\n  const delayValue = getElementStyle(element, transitionDelay);\n  const delayScale = delayValue.includes('ms') ? /* istanbul ignore next */1 : 1000;\n  const duration = propertyValue && propertyValue !== 'none'\n    ? parseFloat(delayValue) * delayScale : 0;\n\n  return !Number.isNaN(duration) ? duration : /* istanbul ignore next */0;\n}\n\n/**\n * A global namespace for 'transitionDuration' string.\n * @type {string}\n */\nconst transitionDuration = 'transitionDuration';\n\n/**\n * Utility to get the computed `transitionDuration`\n * from Element in miliseconds.\n *\n * @param {HTMLElement} element target\n * @return {number} the value in miliseconds\n */\nfunction getElementTransitionDuration(element) {\n  const propertyValue = getElementStyle(element, transitionProperty);\n  const durationValue = getElementStyle(element, transitionDuration);\n  const durationScale = durationValue.includes('ms') ? /* istanbul ignore next */1 : 1000;\n  const duration = propertyValue && propertyValue !== 'none'\n    ? parseFloat(durationValue) * durationScale : 0;\n\n  return !Number.isNaN(duration) ? duration : /* istanbul ignore next */0;\n}\n\n/**\n * Shortcut for the `Element.dispatchEvent(Event)` method.\n *\n * @param {HTMLElement} element is the target\n * @param {Event} event is the `Event` object\n */\nconst dispatchEvent = (element, event) => element.dispatchEvent(event);\n\n/**\n * Utility to make sure callbacks are consistently\n * called when transition ends.\n *\n * @param {HTMLElement} element target\n * @param {EventListener} handler `transitionend` callback\n */\nfunction emulateTransitionEnd(element, handler) {\n  let called = 0;\n  const endEvent = new Event(transitionEndEvent);\n  const duration = getElementTransitionDuration(element);\n  const delay = getElementTransitionDelay(element);\n\n  if (duration) {\n    /**\n     * Wrap the handler in on -> off callback\n     * @type {EventListener} e Event object\n     */\n    const transitionEndWrapper = (e) => {\n      /* istanbul ignore else */\n      if (e.target === element) {\n        handler.apply(element, [e]);\n        element.removeEventListener(transitionEndEvent, transitionEndWrapper);\n        called = 1;\n      }\n    };\n    element.addEventListener(transitionEndEvent, transitionEndWrapper);\n    setTimeout(() => {\n      /* istanbul ignore next */\n      if (!called) dispatchEvent(element, endEvent);\n    }, duration + delay + 17);\n  } else {\n    handler.apply(element, [endEvent]);\n  }\n}\n\n/**\n * Checks if an object is a `Node`.\n *\n * @param {any} node the target object\n * @returns {boolean} the query result\n */\nconst isNode = (element) => (element && [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n  .some((x) => +element.nodeType === x)) || false;\n\n/**\n * Check if a target object is `Window`.\n * => equivalent to `object instanceof Window`\n *\n * @param {any} object the target object\n * @returns {boolean} the query result\n */\nconst isWindow = (object) => (object && object.constructor.name === 'Window') || false;\n\n/**\n * Checks if an object is a `Document`.\n * @see https://dom.spec.whatwg.org/#node\n *\n * @param {any} object the target object\n * @returns {boolean} the query result\n */\nconst isDocument = (object) => (object && object.nodeType === 9) || false;\n\n/**\n * Returns the `document` or the `#document` element.\n * @see https://github.com/floating-ui/floating-ui\n * @param {(Node | Window)=} node\n * @returns {Document}\n */\nfunction getDocument(node) {\n  // node instanceof Document\n  if (isDocument(node)) return node;\n  // node instanceof Node\n  if (isNode(node)) return node.ownerDocument;\n  // node instanceof Window\n  if (isWindow(node)) return node.document;\n  // node is undefined | NULL\n  return window.document;\n}\n\n/**\n * Utility to check if target is typeof `HTMLElement`, `Element`, `Node`\n * or find one that matches a selector.\n *\n * @param {Node | string} selector the input selector or target element\n * @param {ParentNode=} parent optional node to look into\n * @return {HTMLElement?} the `HTMLElement` or `querySelector` result\n */\nfunction querySelector(selector, parent) {\n  if (isNode(selector)) {\n    return selector;\n  }\n  const lookUp = isNode(parent) ? parent : getDocument();\n\n  return lookUp.querySelector(selector);\n}\n\n/**\n * Shortcut for `HTMLElement.closest` method which also works\n * with children of `ShadowRoot`. The order of the parameters\n * is intentional since they're both required.\n *\n * @see https://stackoverflow.com/q/54520554/803358\n *\n * @param {HTMLElement} element Element to look into\n * @param {string} selector the selector name\n * @return {HTMLElement?} the query result\n */\nfunction closest(element, selector) {\n  return element ? (element.closest(selector)\n    // break out of `ShadowRoot`\n    || closest(element.getRootNode().host, selector)) : null;\n}\n\n/**\n * Shortcut for `Object.assign()` static method.\n * @param  {Record<string, any>} obj a target object\n * @param  {Record<string, any>} source a source object\n */\nconst ObjectAssign = (obj, source) => Object.assign(obj, source);\n\n/**\n * Check class in `HTMLElement.classList`.\n *\n * @param {HTMLElement} element target\n * @param {string} classNAME to check\n * @returns {boolean}\n */\nfunction hasClass(element, classNAME) {\n  return element.classList.contains(classNAME);\n}\n\n/**\n * Remove class from `HTMLElement.classList`.\n *\n * @param {HTMLElement} element target\n * @param {string} classNAME to remove\n * @returns {void}\n */\nfunction removeClass(element, classNAME) {\n  element.classList.remove(classNAME);\n}\n\n/**\n * Checks if an element is an `HTMLElement`.\n * @see https://dom.spec.whatwg.org/#node\n *\n * @param {any} element the target object\n * @returns {boolean} the query result\n */\nconst isHTMLElement = (element) => (element && element.nodeType === 1) || false;\n\n/** @type {Map<string, Map<HTMLElement, Record<string, any>>>} */\nconst componentData = new Map();\n/**\n * An interface for web components background data.\n * @see https://github.com/thednp/bootstrap.native/blob/master/src/components/base-component.js\n */\nconst Data = {\n  /**\n   * Sets web components data.\n   * @param {HTMLElement} element target element\n   * @param {string} component the component's name or a unique key\n   * @param {Record<string, any>} instance the component instance\n   */\n  set: (element, component, instance) => {\n    if (!isHTMLElement(element)) return;\n\n    /* istanbul ignore else */\n    if (!componentData.has(component)) {\n      componentData.set(component, new Map());\n    }\n\n    const instanceMap = componentData.get(component);\n    // not undefined, but defined right above\n    instanceMap.set(element, instance);\n  },\n\n  /**\n   * Returns all instances for specified component.\n   * @param {string} component the component's name or a unique key\n   * @returns {Map<HTMLElement, Record<string, any>>?} all the component instances\n   */\n  getAllFor: (component) => {\n    const instanceMap = componentData.get(component);\n\n    return instanceMap || null;\n  },\n\n  /**\n   * Returns the instance associated with the target.\n   * @param {HTMLElement} element target element\n   * @param {string} component the component's name or a unique key\n   * @returns {Record<string, any>?} the instance\n   */\n  get: (element, component) => {\n    if (!isHTMLElement(element) || !component) return null;\n    const allForC = Data.getAllFor(component);\n    const instance = element && allForC && allForC.get(element);\n\n    return instance || null;\n  },\n\n  /**\n   * Removes web components data.\n   * @param {HTMLElement} element target element\n   * @param {string} component the component's name or a unique key\n   */\n  remove: (element, component) => {\n    const instanceMap = componentData.get(component);\n    if (!instanceMap || !isHTMLElement(element)) return;\n\n    instanceMap.delete(element);\n\n    /* istanbul ignore else */\n    if (instanceMap.size === 0) {\n      componentData.delete(component);\n    }\n  },\n};\n\n/**\n * An alias for `Data.get()`.\n * @type {SHORTY.getInstance<any>}\n */\nconst getInstance = (target, component) => Data.get(target, component);\n\n/**\n * Checks if an object is an `Object`.\n *\n * @param {any} obj the target object\n * @returns {boolean} the query result\n */\nconst isObject = (obj) => (typeof obj === 'object') || false;\n\n/**\n * Returns a namespaced `CustomEvent` specific to each component.\n * @param {string} EventType Event.type\n * @param {Record<string, any>=} config Event.options | Event.properties\n * @returns {SHORTY.OriginalEvent} a new namespaced event\n */\nfunction OriginalEvent(EventType, config) {\n  const OriginalCustomEvent = new CustomEvent(EventType, {\n    cancelable: true, bubbles: true,\n  });\n\n  /* istanbul ignore else */\n  if (isObject(config)) {\n    ObjectAssign(OriginalCustomEvent, config);\n  }\n  return OriginalCustomEvent;\n}\n\n/**\n * Global namespace for most components `fade` class.\n */\nconst fadeClass = 'fade';\n\n/**\n * Global namespace for most components `show` class.\n */\nconst showClass = 'show';\n\n/**\n * Global namespace for most components `dismiss` option.\n */\nconst dataBsDismiss = 'data-bs-dismiss';\n\n/** @type {string} */\nconst alertString = 'alert';\n\n/** @type {string} */\nconst alertComponent = 'Alert';\n\n/**\n * Shortcut for `HTMLElement.getAttribute()` method.\n * @param {HTMLElement} element target element\n * @param {string} attribute attribute name\n * @returns {string?} attribute value\n */\nconst getAttribute = (element, attribute) => element.getAttribute(attribute);\n\n/**\n * The raw value or a given component option.\n *\n * @typedef {string | HTMLElement | Function | number | boolean | null} niceValue\n */\n\n/**\n * Utility to normalize component options\n *\n * @param {any} value the input value\n * @return {niceValue} the normalized value\n */\nfunction normalizeValue(value) {\n  if (['true', true].includes(value)) { // boolean\n  // if ('true' === value) { // boolean\n    return true;\n  }\n\n  if (['false', false].includes(value)) { // boolean\n  // if ('false' === value) { // boolean\n    return false;\n  }\n\n  if (value === '' || value === 'null') { // null\n    return null;\n  }\n\n  if (value !== '' && !Number.isNaN(+value)) { // number\n    return +value;\n  }\n\n  // string / function / HTMLElement / object\n  return value;\n}\n\n/**\n * Shortcut for `Object.keys()` static method.\n * @param  {Record<string, any>} obj a target object\n * @returns {string[]}\n */\nconst ObjectKeys = (obj) => Object.keys(obj);\n\n/**\n * Shortcut for `String.toLowerCase()`.\n *\n * @param {string} source input string\n * @returns {string} lowercase output string\n */\nconst toLowerCase = (source) => source.toLowerCase();\n\n/**\n * Utility to normalize component options.\n *\n * @param {HTMLElement} element target\n * @param {Record<string, any>} defaultOps component default options\n * @param {Record<string, any>} inputOps component instance options\n * @param {string=} ns component namespace\n * @return {Record<string, any>} normalized component options object\n */\nfunction normalizeOptions(element, defaultOps, inputOps, ns) {\n  const data = { ...element.dataset };\n  /** @type {Record<string, any>} */\n  const normalOps = {};\n  /** @type {Record<string, any>} */\n  const dataOps = {};\n  const title = 'title';\n\n  ObjectKeys(data).forEach((k) => {\n    const key = ns && k.includes(ns)\n      ? k.replace(ns, '').replace(/[A-Z]/, (match) => toLowerCase(match))\n      : k;\n\n    dataOps[key] = normalizeValue(data[k]);\n  });\n\n  ObjectKeys(inputOps).forEach((k) => {\n    inputOps[k] = normalizeValue(inputOps[k]);\n  });\n\n  ObjectKeys(defaultOps).forEach((k) => {\n    /* istanbul ignore else */\n    if (k in inputOps) {\n      normalOps[k] = inputOps[k];\n    } else if (k in dataOps) {\n      normalOps[k] = dataOps[k];\n    } else {\n      normalOps[k] = k === title\n        ? getAttribute(element, title)\n        : defaultOps[k];\n    }\n  });\n\n  return normalOps;\n}\n\nvar version = \"4.2.0\";\n\nconst Version = version;\n\n/* Native JavaScript for Bootstrap 5 | Base Component\n----------------------------------------------------- */\n\n/** Returns a new `BaseComponent` instance. */\nclass BaseComponent {\n  /**\n   * @param {HTMLElement | string} target `Element` or selector string\n   * @param {BSN.ComponentOptions=} config component instance options\n   */\n  constructor(target, config) {\n    const self = this;\n    const element = querySelector(target);\n\n    if (!element) {\n      throw Error(`${self.name} Error: \"${target}\" is not a valid selector.`);\n    }\n\n    /** @static @type {BSN.ComponentOptions} */\n    self.options = {};\n\n    const prevInstance = Data.get(element, self.name);\n    if (prevInstance) prevInstance.dispose();\n\n    /** @type {HTMLElement} */\n    self.element = element;\n\n    /* istanbul ignore else */\n    if (self.defaults && ObjectKeys(self.defaults).length) {\n      self.options = normalizeOptions(element, self.defaults, (config || {}), 'bs');\n    }\n\n    Data.set(element, self.name, self);\n  }\n\n  /* eslint-disable */\n  /* istanbul ignore next */\n  /** @static */\n  get version() { return Version; }\n\n  /* eslint-enable */\n  /* istanbul ignore next */\n  /** @static */\n  get name() { return this.constructor.name; }\n\n  /* istanbul ignore next */\n  /** @static */\n  get defaults() { return this.constructor.defaults; }\n\n  /**\n   * Removes component from target element;\n   */\n  dispose() {\n    const self = this;\n    Data.remove(self.element, self.name);\n    ObjectKeys(self).forEach((prop) => { self[prop] = null; });\n  }\n}\n\n/* Native JavaScript for Bootstrap 5 | Alert\n-------------------------------------------- */\n\n// ALERT PRIVATE GC\n// ================\nconst alertSelector = `.${alertString}`;\nconst alertDismissSelector = `[${dataBsDismiss}=\"${alertString}\"]`;\n\n/**\n * Static method which returns an existing `Alert` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Alert>}\n */\nconst getAlertInstance = (element) => getInstance(element, alertComponent);\n\n/**\n* An `Alert` initialization callback.\n* @type {BSN.InitCallback<Alert>}\n*/\nconst alertInitCallback = (element) => new Alert(element);\n\n// ALERT CUSTOM EVENTS\n// ===================\nconst closeAlertEvent = OriginalEvent(`close.bs.${alertString}`);\nconst closedAlertEvent = OriginalEvent(`closed.bs.${alertString}`);\n\n// ALERT EVENT HANDLER\n// ===================\n/**\n * Alert `transitionend` callback.\n * @param {Alert} self target Alert instance\n */\nfunction alertTransitionEnd(self) {\n  const { element } = self;\n  toggleAlertHandler(self);\n\n  dispatchEvent(element, closedAlertEvent);\n\n  self.dispose();\n  element.remove();\n}\n\n// ALERT PRIVATE METHOD\n// ====================\n/**\n * Toggle on / off the `click` event listener.\n * @param {Alert} self the target alert instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleAlertHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { dismiss } = self;\n  /* istanbul ignore else */\n  if (dismiss) action(dismiss, mouseclickEvent, self.close);\n}\n\n// ALERT DEFINITION\n// ================\n/** Creates a new Alert instance. */\nclass Alert extends BaseComponent {\n  /** @param {HTMLElement | string} target element or selector */\n  constructor(target) {\n    super(target);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n\n    // the dismiss button\n    /** @static @type {HTMLElement?} */\n    self.dismiss = querySelector(alertDismissSelector, element);\n\n    // add event listener\n    toggleAlertHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return alertComponent; }\n  /* eslint-enable */\n\n  // ALERT PUBLIC METHODS\n  // ====================\n  /**\n   * Public method that hides the `.alert` element from the user,\n   * disposes the instance once animation is complete, then\n   * removes the element from the DOM.\n   *\n   * @param {Event=} e most likely the `click` event\n   * @this {Alert} the `Alert` instance or `EventTarget`\n   */\n  close(e) {\n    const self = e ? getAlertInstance(closest(this, alertSelector)) : this;\n    const { element } = self;\n\n    /* istanbul ignore else */\n    if (element && hasClass(element, showClass)) {\n      dispatchEvent(element, closeAlertEvent);\n      if (closeAlertEvent.defaultPrevented) return;\n\n      removeClass(element, showClass);\n\n      if (hasClass(element, fadeClass)) {\n        emulateTransitionEnd(element, () => alertTransitionEnd(self));\n      } else alertTransitionEnd(self);\n    }\n  }\n\n  /** Remove the component from target element. */\n  dispose() {\n    toggleAlertHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Alert, {\n  selector: alertSelector,\n  init: alertInitCallback,\n  getInstance: getAlertInstance,\n});\n\n/**\n * A global namespace for aria-pressed.\n * @type {string}\n */\nconst ariaPressed = 'aria-pressed';\n\n/**\n * Shortcut for `HTMLElement.setAttribute()` method.\n * @param  {HTMLElement} element target element\n * @param  {string} attribute attribute name\n * @param  {string} value attribute value\n * @returns {void}\n */\nconst setAttribute = (element, attribute, value) => element.setAttribute(attribute, value);\n\n/**\n * Add class to `HTMLElement.classList`.\n *\n * @param {HTMLElement} element target\n * @param {string} classNAME to add\n * @returns {void}\n */\nfunction addClass(element, classNAME) {\n  element.classList.add(classNAME);\n}\n\n/**\n * Global namespace for most components active class.\n */\nconst activeClass = 'active';\n\n/**\n * Global namespace for most components `toggle` option.\n */\nconst dataBsToggle = 'data-bs-toggle';\n\n/** @type {string} */\nconst buttonString = 'button';\n\n/** @type {string} */\nconst buttonComponent = 'Button';\n\n/* Native JavaScript for Bootstrap 5 | Button\n---------------------------------------------*/\n\n// BUTTON PRIVATE GC\n// =================\nconst buttonSelector = `[${dataBsToggle}=\"${buttonString}\"]`;\n\n/**\n * Static method which returns an existing `Button` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Button>}\n */\nconst getButtonInstance = (element) => getInstance(element, buttonComponent);\n\n/**\n * A `Button` initialization callback.\n * @type {BSN.InitCallback<Button>}\n */\nconst buttonInitCallback = (element) => new Button(element);\n\n// BUTTON PRIVATE METHOD\n// =====================\n/**\n * Toggles on/off the `click` event listener.\n * @param {Button} self the `Button` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleButtonHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, self.toggle);\n}\n\n// BUTTON DEFINITION\n// =================\n/** Creates a new `Button` instance. */\nclass Button extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target usually a `.btn` element\n   */\n  constructor(target) {\n    super(target);\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n\n    // set initial state\n    /** @type {boolean} */\n    self.isActive = hasClass(element, activeClass);\n    setAttribute(element, ariaPressed, `${!!self.isActive}`);\n\n    // add event listener\n    toggleButtonHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return buttonComponent; }\n  /* eslint-enable */\n\n  // BUTTON PUBLIC METHODS\n  // =====================\n  /**\n   * Toggles the state of the target button.\n   * @param {MouseEvent} e usually `click` Event object\n   */\n  toggle(e) {\n    if (e) e.preventDefault();\n    const self = e ? getButtonInstance(this) : this;\n    if (!self.element) return;\n    const { element, isActive } = self;\n\n    if (hasClass(element, 'disabled')) return;\n\n    const action = isActive ? removeClass : addClass;\n    action(element, activeClass);\n    setAttribute(element, ariaPressed, isActive ? 'false' : 'true');\n    self.isActive = hasClass(element, activeClass);\n  }\n\n  /** Removes the `Button` component from the target element. */\n  dispose() {\n    toggleButtonHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Button, {\n  selector: buttonSelector,\n  init: buttonInitCallback,\n  getInstance: getButtonInstance,\n});\n\n/**\n * A global namespace for `mouseenter` event.\n * @type {string}\n */\nconst mouseenterEvent = 'mouseenter';\n\n/**\n * A global namespace for `mouseleave` event.\n * @type {string}\n */\nconst mouseleaveEvent = 'mouseleave';\n\n/**\n * A global namespace for `keydown` event.\n * @type {string}\n */\nconst keydownEvent = 'keydown';\n\n/**\n * A global namespace for `ArrowLeft` key.\n * @type {string} e.which = 37 equivalent\n */\nconst keyArrowLeft = 'ArrowLeft';\n\n/**\n * A global namespace for `ArrowRight` key.\n * @type {string} e.which = 39 equivalent\n */\nconst keyArrowRight = 'ArrowRight';\n\n/**\n * A global namespace for `pointerdown` event.\n * @type {string}\n */\nconst pointerdownEvent = 'pointerdown';\n\n/**\n * A global namespace for `pointermove` event.\n * @type {string}\n */\nconst pointermoveEvent = 'pointermove';\n\n/**\n * A global namespace for `pointerup` event.\n * @type {string}\n */\nconst pointerupEvent = 'pointerup';\n\n/**\n * Returns the bounding client rect of a target `HTMLElement`.\n *\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element event.target\n * @param {boolean=} includeScale when *true*, the target scale is also computed\n * @returns {SHORTY.BoundingClientRect} the bounding client rect object\n */\nfunction getBoundingClientRect(element, includeScale) {\n  const {\n    width, height, top, right, bottom, left,\n  } = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    const { offsetWidth, offsetHeight } = element;\n    scaleX = offsetWidth > 0 ? Math.round(width) / offsetWidth\n      : /* istanbul ignore next */1;\n    scaleY = offsetHeight > 0 ? Math.round(height) / offsetHeight\n      : /* istanbul ignore next */1;\n  }\n\n  return {\n    width: width / scaleX,\n    height: height / scaleY,\n    top: top / scaleY,\n    right: right / scaleX,\n    bottom: bottom / scaleY,\n    left: left / scaleX,\n    x: left / scaleX,\n    y: top / scaleY,\n  };\n}\n\n/**\n * Returns the `document.documentElement` or the `<html>` element.\n *\n * @param {(Node | Window)=} node\n * @returns {HTMLHtmlElement}\n */\nfunction getDocumentElement(node) {\n  return getDocument(node).documentElement;\n}\n\n/**\n * Utility to determine if an `HTMLElement`\n * is partially visible in viewport.\n *\n * @param {HTMLElement} element target\n * @return {boolean} the query result\n */\nconst isElementInScrollRange = (element) => {\n  if (!element || !isNode(element)) return false;\n\n  const { top, bottom } = getBoundingClientRect(element);\n  const { clientHeight } = getDocumentElement(element);\n  return top <= clientHeight && bottom >= 0;\n};\n\n/**\n * Checks if a page is Right To Left.\n * @param {HTMLElement=} node the target\n * @returns {boolean} the query result\n */\nconst isRTL = (node) => getDocumentElement(node).dir === 'rtl';\n\n/**\n * A shortcut for `(document|Element).querySelectorAll`.\n *\n * @param {string} selector the input selector\n * @param {ParentNode=} parent optional node to look into\n * @return {NodeListOf<HTMLElement>} the query result\n */\nfunction querySelectorAll(selector, parent) {\n  const lookUp = isNode(parent) ? parent : getDocument();\n  return lookUp.querySelectorAll(selector);\n}\n\n/**\n * Shortcut for `HTMLElement.getElementsByClassName` method. Some `Node` elements\n * like `ShadowRoot` do not support `getElementsByClassName`.\n *\n * @param {string} selector the class name\n * @param {ParentNode=} parent optional Element to look into\n * @return {HTMLCollectionOf<HTMLElement>} the 'HTMLCollection'\n */\nfunction getElementsByClassName(selector, parent) {\n  const lookUp = isNode(parent) ? parent : getDocument();\n  return lookUp.getElementsByClassName(selector);\n}\n\n/** @type {Map<HTMLElement, any>} */\nconst TimeCache = new Map();\n/**\n * An interface for one or more `TimerHandler`s per `Element`.\n * @see https://github.com/thednp/navbar.js/\n */\nconst Timer = {\n  /**\n   * Sets a new timeout timer for an element, or element -> key association.\n   * @param {HTMLElement} element target element\n   * @param {ReturnType<TimerHandler>} callback the callback\n   * @param {number} delay the execution delay\n   * @param {string=} key a unique key\n   */\n  set: (element, callback, delay, key) => {\n    if (!isHTMLElement(element)) return;\n\n    /* istanbul ignore else */\n    if (key && key.length) {\n      /* istanbul ignore else */\n      if (!TimeCache.has(element)) {\n        TimeCache.set(element, new Map());\n      }\n      const keyTimers = TimeCache.get(element);\n      keyTimers.set(key, setTimeout(callback, delay));\n    } else {\n      TimeCache.set(element, setTimeout(callback, delay));\n    }\n  },\n\n  /**\n   * Returns the timer associated with the target.\n   * @param {HTMLElement} element target element\n   * @param {string=} key a unique\n   * @returns {number?} the timer\n   */\n  get: (element, key) => {\n    if (!isHTMLElement(element)) return null;\n    const keyTimers = TimeCache.get(element);\n\n    if (key && key.length && keyTimers && keyTimers.get) {\n      return keyTimers.get(key) || /* istanbul ignore next */null;\n    }\n    return keyTimers || null;\n  },\n\n  /**\n   * Clears the element's timer.\n   * @param {HTMLElement} element target element\n   * @param {string=} key a unique key\n   */\n  clear: (element, key) => {\n    if (!isHTMLElement(element)) return;\n\n    if (key && key.length) {\n      const keyTimers = TimeCache.get(element);\n      /* istanbul ignore else */\n      if (keyTimers && keyTimers.get) {\n        clearTimeout(keyTimers.get(key));\n        keyTimers.delete(key);\n        /* istanbul ignore else */\n        if (keyTimers.size === 0) {\n          TimeCache.delete(element);\n        }\n      }\n    } else {\n      clearTimeout(TimeCache.get(element));\n      TimeCache.delete(element);\n    }\n  },\n};\n\n/**\n * Utility to force re-paint of an `HTMLElement` target.\n *\n * @param {HTMLElement} element is the target\n * @return {number} the `Element.offsetHeight` value\n */\nconst reflow = (element) => element.offsetHeight;\n\n/**\n * A global namespace for most scroll event listeners.\n * @type {Partial<AddEventListenerOptions>}\n */\nconst passiveHandler = { passive: true };\n\n/**\n * Global namespace for most components `target` option.\n */\nconst dataBsTarget = 'data-bs-target';\n\n/** @type {string} */\nconst carouselString = 'carousel';\n\n/** @type {string} */\nconst carouselComponent = 'Carousel';\n\n/**\n * Global namespace for most components `parent` option.\n */\nconst dataBsParent = 'data-bs-parent';\n\n/**\n * Global namespace for most components `container` option.\n */\nconst dataBsContainer = 'data-bs-container';\n\n/**\n * Returns the `Element` that THIS one targets\n * via `data-bs-target`, `href`, `data-bs-parent` or `data-bs-container`.\n *\n * @param {HTMLElement} element the target element\n * @returns {HTMLElement?} the query result\n */\nfunction getTargetElement(element) {\n  const targetAttr = [dataBsTarget, dataBsParent, dataBsContainer, 'href'];\n  const doc = getDocument(element);\n\n  return targetAttr.map((att) => {\n    const attValue = getAttribute(element, att);\n    if (attValue) {\n      return att === dataBsParent ? closest(element, attValue) : querySelector(attValue, doc);\n    }\n    return null;\n  }).filter((x) => x)[0];\n}\n\n/* Native JavaScript for Bootstrap 5 | Carousel\n----------------------------------------------- */\n\n// CAROUSEL PRIVATE GC\n// ===================\nconst carouselSelector = `[data-bs-ride=\"${carouselString}\"]`;\nconst carouselItem = `${carouselString}-item`;\nconst dataBsSlideTo = 'data-bs-slide-to';\nconst dataBsSlide = 'data-bs-slide';\nconst pausedClass = 'paused';\n\nconst carouselDefaults = {\n  pause: 'hover',\n  keyboard: false,\n  touch: true,\n  interval: 5000,\n};\n\n/**\n * Static method which returns an existing `Carousel` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Carousel>}\n */\nconst getCarouselInstance = (element) => getInstance(element, carouselComponent);\n\n/**\n * A `Carousel` initialization callback.\n * @type {BSN.InitCallback<Carousel>}\n */\nconst carouselInitCallback = (element) => new Carousel(element);\n\nlet startX = 0;\nlet currentX = 0;\nlet endX = 0;\n\n// CAROUSEL CUSTOM EVENTS\n// ======================\nconst carouselSlideEvent = OriginalEvent(`slide.bs.${carouselString}`);\nconst carouselSlidEvent = OriginalEvent(`slid.bs.${carouselString}`);\n\n// CAROUSEL EVENT HANDLERS\n// =======================\n/**\n * The `transitionend` event listener of the `Carousel`.\n * @param {Carousel} self the `Carousel` instance\n */\nfunction carouselTransitionEndHandler(self) {\n  const {\n    index, direction, element, slides, options,\n  } = self;\n\n  // discontinue disposed instances\n  /* istanbul ignore else */\n  if (self.isAnimating && getCarouselInstance(element)) {\n    const activeItem = getActiveIndex(self);\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    addClass(slides[index], activeClass);\n    removeClass(slides[index], `${carouselItem}-${orientation}`);\n    removeClass(slides[index], `${carouselItem}-${directionClass}`);\n\n    removeClass(slides[activeItem], activeClass);\n    removeClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n    dispatchEvent(element, carouselSlidEvent);\n    Timer.clear(element, dataBsSlide);\n\n    // check for element, might have been disposed\n    if (!getDocument(element).hidden && options.interval\n      && !self.isPaused) {\n      self.cycle();\n    }\n  }\n}\n\n/**\n * Handles the `mouseenter` events when *options.pause*\n * is set to `hover`.\n *\n * @this {HTMLElement}\n */\nfunction carouselPauseHandler() {\n  const element = this;\n  const self = getCarouselInstance(element);\n  /* istanbul ignore else */\n  if (self && !self.isPaused && !Timer.get(element, pausedClass)) {\n    addClass(element, pausedClass);\n  }\n}\n\n/**\n * Handles the `mouseleave` events when *options.pause*\n * is set to `hover`.\n *\n * @this {HTMLElement}\n */\nfunction carouselResumeHandler() {\n  const element = this;\n  const self = getCarouselInstance(element);\n  /* istanbul ignore else */\n  if (self && self.isPaused && !Timer.get(element, pausedClass)) {\n    self.cycle();\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` indicators.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction carouselIndicatorHandler(e) {\n  e.preventDefault();\n  const indicator = this;\n  const element = closest(indicator, carouselSelector) || getTargetElement(indicator);\n  const self = getCarouselInstance(element);\n\n  if (!self || self.isAnimating) return;\n\n  const newIndex = +getAttribute(indicator, dataBsSlideTo);\n\n  if (indicator && !hasClass(indicator, activeClass) // event target is not active\n    && !Number.isNaN(newIndex)) { // AND has the specific attribute\n    self.to(newIndex); // do the slide\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` arrows.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction carouselControlsHandler(e) {\n  e.preventDefault();\n  const control = this;\n  const element = closest(control, carouselSelector) || getTargetElement(control);\n  const self = getCarouselInstance(element);\n\n  if (!self || self.isAnimating) return;\n  const orientation = getAttribute(control, dataBsSlide);\n\n  /* istanbul ignore else */\n  if (orientation === 'next') {\n    self.next();\n  } else if (orientation === 'prev') {\n    self.prev();\n  }\n}\n\n/**\n * Handles the keyboard `keydown` event for the visible `Carousel` elements.\n *\n * @param {KeyboardEvent} e the `Event` object\n */\nfunction carouselKeyHandler({ code, target }) {\n  const doc = getDocument(target);\n  const [element] = [...querySelectorAll(carouselSelector, doc)]\n    .filter((x) => isElementInScrollRange(x));\n  const self = getCarouselInstance(element);\n\n  /* istanbul ignore next */\n  if (!self || self.isAnimating || /textarea|input/i.test(target.tagName)) return;\n  const RTL = isRTL(element);\n  const arrowKeyNext = !RTL ? keyArrowRight : keyArrowLeft;\n  const arrowKeyPrev = !RTL ? keyArrowLeft : keyArrowRight;\n\n  /* istanbul ignore else */\n  if (code === arrowKeyPrev) self.prev();\n  else if (code === arrowKeyNext) self.next();\n}\n\n// CAROUSEL TOUCH HANDLERS\n// =======================\n/**\n * Handles the `pointerdown` event for the `Carousel` element.\n *\n * @this {HTMLElement}\n * @param {PointerEvent} e the `Event` object\n */\nfunction carouselPointerDownHandler(e) {\n  const element = this;\n  const { target } = e;\n  const self = getCarouselInstance(element);\n\n  // filter pointer event on controls & indicators\n  const { controls, indicators } = self;\n  if ([...controls, ...indicators].some((el) => (el === target || el.contains(target)))) {\n    return;\n  }\n\n  if (!self || self.isAnimating || self.isTouch) { return; }\n\n  startX = e.pageX;\n\n  /* istanbul ignore else */\n  if (element.contains(target)) {\n    self.isTouch = true;\n    toggleCarouselTouchHandlers(self, true);\n  }\n}\n\n/**\n * Handles the `pointermove` event for the `Carousel` element.\n *\n * @this {HTMLElement}\n * @param {PointerEvent} e\n */\nfunction carouselPointerMoveHandler(e) {\n  // const self = getCarouselInstance(this);\n\n  // if (!self || !self.isTouch) { return; }\n\n  currentX = e.pageX;\n}\n\n/**\n * Handles the `pointerup` event for the `Carousel` element.\n *\n * @this {HTMLElement}\n\n * @param {PointerEvent} e\n */\nfunction carouselPointerUpHandler(e) {\n  const { target } = e;\n  const doc = getDocument(target);\n  const self = [...querySelectorAll(carouselSelector, doc)]\n    .map((c) => getCarouselInstance(c)).find((i) => i.isTouch);\n\n  // impossible to satisfy\n  /* istanbul ignore next */\n  if (!self) { return; }\n\n  const { element, index } = self;\n  const RTL = isRTL(target);\n\n  self.isTouch = false;\n  toggleCarouselTouchHandlers(self);\n\n  if (doc.getSelection().toString().length) {\n    // reset pointer position\n    startX = 0; currentX = 0; endX = 0;\n    return;\n  }\n\n  endX = e.pageX;\n\n  // the event target is outside the carousel context\n  // OR swipe distance is less than 120px\n  /* istanbul ignore else */\n  if (!element.contains(target) || Math.abs(startX - endX) < 120) {\n    // reset pointer position\n    startX = 0; currentX = 0; endX = 0;\n    return;\n  }\n  // OR determine next index to slide to\n  /* istanbul ignore else */\n  if (currentX < startX) {\n    self.to(index + (RTL ? -1 : 1));\n  } else if (currentX > startX) {\n    self.to(index + (RTL ? 1 : -1));\n  }\n  // reset pointer position\n  startX = 0; currentX = 0; endX = 0;\n}\n\n// CAROUSEL PRIVATE METHODS\n// ========================\n/**\n * Sets active indicator for the `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {number} pageIndex the index of the new active indicator\n */\nfunction activateCarouselIndicator(self, pageIndex) {\n  const { indicators } = self;\n  [...indicators].forEach((x) => removeClass(x, activeClass));\n\n  /* istanbul ignore else */\n  if (self.indicators[pageIndex]) addClass(indicators[pageIndex], activeClass);\n}\n\n/**\n * Toggles the pointer event listeners for a given `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {boolean=} add when `TRUE` event listeners are added\n */\nfunction toggleCarouselTouchHandlers(self, add) {\n  const { element } = self;\n  const action = add ? addListener : removeListener;\n  action(getDocument(element), pointermoveEvent, carouselPointerMoveHandler, passiveHandler);\n  action(getDocument(element), pointerupEvent, carouselPointerUpHandler, passiveHandler);\n}\n\n/**\n * Toggles all event listeners for a given `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {boolean=} add when `TRUE` event listeners are added\n */\nfunction toggleCarouselHandlers(self, add) {\n  const {\n    element, options, slides, controls, indicators,\n  } = self;\n  const {\n    touch, pause, interval, keyboard,\n  } = options;\n  const action = add ? addListener : removeListener;\n\n  if (pause && interval) {\n    action(element, mouseenterEvent, carouselPauseHandler);\n    action(element, mouseleaveEvent, carouselResumeHandler);\n  }\n\n  if (touch && slides.length > 2) {\n    action(element, pointerdownEvent, carouselPointerDownHandler, passiveHandler);\n  }\n\n  /* istanbul ignore else */\n  if (controls.length) {\n    controls.forEach((arrow) => {\n      /* istanbul ignore else */\n      if (arrow) action(arrow, mouseclickEvent, carouselControlsHandler);\n    });\n  }\n\n  /* istanbul ignore else */\n  if (indicators.length) {\n    indicators.forEach((indicator) => {\n      action(indicator, mouseclickEvent, carouselIndicatorHandler);\n    });\n  }\n\n  if (keyboard) action(getDocument(element), keydownEvent, carouselKeyHandler);\n}\n\n/**\n * Returns the index of the current active item.\n * @param {Carousel} self the `Carousel` instance\n * @returns {number} the query result\n */\nfunction getActiveIndex(self) {\n  const { slides, element } = self;\n  const activeItem = querySelector(`.${carouselItem}.${activeClass}`, element);\n  return [...slides].indexOf(activeItem);\n}\n\n// CAROUSEL DEFINITION\n// ===================\n/** Creates a new `Carousel` instance. */\nclass Carousel extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target mostly a `.carousel` element\n   * @param {BSN.Options.Carousel=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n    // initialization element\n    const { element } = self;\n\n    // additional properties\n    /** @type {string} */\n    self.direction = isRTL(element) ? 'right' : 'left';\n    /** @type {number} */\n    self.index = 0;\n    /** @type {boolean} */\n    self.isTouch = false;\n\n    // carousel elements\n    // a LIVE collection is prefferable\n    self.slides = getElementsByClassName(carouselItem, element);\n    const { slides } = self;\n\n    // invalidate when not enough items\n    // no need to go further\n    if (slides.length < 2) { return; }\n    // external controls must be within same document context\n    const doc = getDocument(element);\n\n    self.controls = [\n      ...querySelectorAll(`[${dataBsSlide}]`, element),\n      ...querySelectorAll(`[${dataBsSlide}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n    ];\n\n    /** @type {HTMLElement?} */\n    self.indicator = querySelector(`.${carouselString}-indicators`, element);\n\n    // a LIVE collection is prefferable\n    /** @type {HTMLElement[]} */\n    self.indicators = [\n      ...(self.indicator ? querySelectorAll(`[${dataBsSlideTo}]`, self.indicator) : []),\n      ...querySelectorAll(`[${dataBsSlideTo}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n    ];\n\n    // set JavaScript and DATA API options\n    const { options } = self;\n\n    // don't use TRUE as interval, it's actually 0, use the default 5000ms better\n    self.options.interval = options.interval === true\n      ? carouselDefaults.interval\n      : options.interval;\n\n    // set first slide active if none\n    /* istanbul ignore else */\n    if (getActiveIndex(self) < 0) {\n      addClass(slides[0], activeClass);\n      /* istanbul ignore else */\n      if (self.indicators.length) activateCarouselIndicator(self, 0);\n    }\n\n    // attach event handlers\n    toggleCarouselHandlers(self, true);\n\n    // start to cycle if interval is set\n    if (options.interval) self.cycle();\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return carouselComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return carouselDefaults; }\n  /* eslint-enable */\n\n  /**\n   * Check if instance is paused.\n   * @returns {boolean}\n  */\n  get isPaused() {\n    return hasClass(this.element, pausedClass);\n  }\n\n  /**\n   * Check if instance is animating.\n   * @returns {boolean}\n  */\n  get isAnimating() {\n    return querySelector(`.${carouselItem}-next,.${carouselItem}-prev`, this.element) !== null;\n  }\n\n  // CAROUSEL PUBLIC METHODS\n  // =======================\n  /** Slide automatically through items. */\n  cycle() {\n    const self = this;\n    const {\n      element, options, isPaused, index,\n    } = self;\n\n    Timer.clear(element, carouselString);\n    if (isPaused) {\n      Timer.clear(element, pausedClass);\n      removeClass(element, pausedClass);\n    }\n\n    Timer.set(element, () => {\n      // it's very important to check self.element\n      // where instance might have been disposed\n      /* istanbul ignore else */\n      if (self.element && !self.isPaused && !self.isTouch\n        && isElementInScrollRange(element)) {\n        self.to(index + 1);\n      }\n    }, options.interval, carouselString);\n  }\n\n  /** Pause the automatic cycle. */\n  pause() {\n    const self = this;\n    const { element, options } = self;\n    /* istanbul ignore else */\n    if (!self.isPaused && options.interval) {\n      addClass(element, pausedClass);\n      Timer.set(element, () => {}, 1, pausedClass);\n    }\n  }\n\n  /** Slide to the next item. */\n  next() {\n    const self = this;\n    /* istanbul ignore else */\n    if (!self.isAnimating) { self.to(self.index + 1); }\n  }\n\n  /** Slide to the previous item. */\n  prev() {\n    const self = this;\n    /* istanbul ignore else */\n    if (!self.isAnimating) { self.to(self.index - 1); }\n  }\n\n  /**\n   * Jump to the item with the `idx` index.\n   * @param {number} idx the index of the item to jump to\n   */\n  to(idx) {\n    const self = this;\n    const {\n      element, slides, options,\n    } = self;\n    const activeItem = getActiveIndex(self);\n    const RTL = isRTL(element);\n    let next = idx;\n\n    // when controled via methods, make sure to check again\n    // first return if we're on the same item #227\n    // `to()` must be SPAM protected by Timer\n    if (self.isAnimating || activeItem === next || Timer.get(element, dataBsSlide)) return;\n\n    // determine transition direction\n    /* istanbul ignore else */\n    if ((activeItem < next) || (activeItem === 0 && next === slides.length - 1)) {\n      self.direction = RTL ? 'right' : 'left'; // next\n    } else if ((activeItem > next) || (activeItem === slides.length - 1 && next === 0)) {\n      self.direction = RTL ? 'left' : 'right'; // prev\n    }\n    const { direction } = self;\n\n    // find the right next index\n    if (next < 0) { next = slides.length - 1; } else if (next >= slides.length) { next = 0; }\n\n    // orientation, class name, eventProperties\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    const eventProperties = {\n      relatedTarget: slides[next],\n      from: activeItem,\n      to: next,\n      direction,\n    };\n\n    // update event properties\n    ObjectAssign(carouselSlideEvent, eventProperties);\n    ObjectAssign(carouselSlidEvent, eventProperties);\n\n    // discontinue when prevented\n    dispatchEvent(element, carouselSlideEvent);\n    if (carouselSlideEvent.defaultPrevented) return;\n\n    // update index\n    self.index = next;\n    activateCarouselIndicator(self, next);\n\n    if (getElementTransitionDuration(slides[next]) && hasClass(element, 'slide')) {\n      Timer.set(element, () => {\n        addClass(slides[next], `${carouselItem}-${orientation}`);\n        reflow(slides[next]);\n        addClass(slides[next], `${carouselItem}-${directionClass}`);\n        addClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n        emulateTransitionEnd(slides[next], () => carouselTransitionEndHandler(self));\n      }, 0, dataBsSlide);\n    } else {\n      addClass(slides[next], activeClass);\n      removeClass(slides[activeItem], activeClass);\n\n      Timer.set(element, () => {\n        Timer.clear(element, dataBsSlide);\n        // check for element, might have been disposed\n        /* istanbul ignore else */\n        if (element && options.interval && !self.isPaused) {\n          self.cycle();\n        }\n\n        dispatchEvent(element, carouselSlidEvent);\n      }, 0, dataBsSlide);\n    }\n  }\n\n  /** Remove `Carousel` component from target. */\n  dispose() {\n    const self = this;\n    const { slides } = self;\n    const itemClasses = ['start', 'end', 'prev', 'next'];\n\n    [...slides].forEach((slide, idx) => {\n      if (hasClass(slide, activeClass)) activateCarouselIndicator(self, idx);\n      itemClasses.forEach((c) => removeClass(slide, `${carouselItem}-${c}`));\n    });\n\n    toggleCarouselHandlers(self);\n    super.dispose();\n  }\n}\n\nObjectAssign(Carousel, {\n  selector: carouselSelector,\n  init: carouselInitCallback,\n  getInstance: getCarouselInstance,\n});\n\n/**\n * A global namespace for aria-expanded.\n * @type {string}\n */\nconst ariaExpanded = 'aria-expanded';\n\n/**\n * Shortcut for `Object.entries()` static method.\n * @param  {Record<string, any>} obj a target object\n * @returns {[string, any][]}\n */\nconst ObjectEntries = (obj) => Object.entries(obj);\n\n/**\n * Shortcut for multiple uses of `HTMLElement.style.propertyName` method.\n * @param  {HTMLElement} element target element\n * @param  {Partial<CSSStyleDeclaration>} styles attribute value\n */\nconst setElementStyle = (element, styles) => {\n  ObjectEntries(styles).forEach(([key, value]) => {\n    if (key.includes('--')) {\n      element.style.setProperty(key, value);\n    } else {\n      const propObject = {}; propObject[key] = value;\n      ObjectAssign(element.style, propObject);\n    }\n  });\n};\n\n/**\n * Global namespace for most components `collapsing` class.\n * As used by `Collapse` / `Tab`.\n */\nconst collapsingClass = 'collapsing';\n\n/** @type {string} */\nconst collapseString = 'collapse';\n\n/** @type {string} */\nconst collapseComponent = 'Collapse';\n\n/* Native JavaScript for Bootstrap 5 | Collapse\n----------------------------------------------- */\n\n// COLLAPSE GC\n// ===========\nconst collapseSelector = `.${collapseString}`;\nconst collapseToggleSelector = `[${dataBsToggle}=\"${collapseString}\"]`;\nconst collapseDefaults = { parent: null };\n\n/**\n * Static method which returns an existing `Collapse` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Collapse>}\n */\nconst getCollapseInstance = (element) => getInstance(element, collapseComponent);\n\n/**\n * A `Collapse` initialization callback.\n * @type {BSN.InitCallback<Collapse>}\n */\nconst collapseInitCallback = (element) => new Collapse(element);\n\n// COLLAPSE CUSTOM EVENTS\n// ======================\nconst showCollapseEvent = OriginalEvent(`show.bs.${collapseString}`);\nconst shownCollapseEvent = OriginalEvent(`shown.bs.${collapseString}`);\nconst hideCollapseEvent = OriginalEvent(`hide.bs.${collapseString}`);\nconst hiddenCollapseEvent = OriginalEvent(`hidden.bs.${collapseString}`);\n\n// COLLAPSE PRIVATE METHODS\n// ========================\n/**\n * Expand the designated `Element`.\n * @param {Collapse} self the `Collapse` instance\n */\nfunction expandCollapse(self) {\n  const {\n    element, parent, triggers,\n  } = self;\n\n  dispatchEvent(element, showCollapseEvent);\n  if (showCollapseEvent.defaultPrevented) return;\n\n  Timer.set(element, () => {}, 17);\n  if (parent) Timer.set(parent, () => {}, 17);\n\n  addClass(element, collapsingClass);\n  removeClass(element, collapseString);\n\n  setElementStyle(element, { height: `${element.scrollHeight}px` });\n\n  emulateTransitionEnd(element, () => {\n    Timer.clear(element);\n    if (parent) Timer.clear(parent);\n\n    triggers.forEach((btn) => setAttribute(btn, ariaExpanded, 'true'));\n\n    removeClass(element, collapsingClass);\n    addClass(element, collapseString);\n    addClass(element, showClass);\n\n    setElementStyle(element, { height: '' });\n\n    dispatchEvent(element, shownCollapseEvent);\n  });\n}\n\n/**\n * Collapse the designated `Element`.\n * @param {Collapse} self the `Collapse` instance\n */\nfunction collapseContent(self) {\n  const {\n    element, parent, triggers,\n  } = self;\n\n  dispatchEvent(element, hideCollapseEvent);\n\n  if (hideCollapseEvent.defaultPrevented) return;\n\n  Timer.set(element, () => {}, 17);\n  if (parent) Timer.set(parent, () => {}, 17);\n\n  setElementStyle(element, { height: `${element.scrollHeight}px` });\n\n  removeClass(element, collapseString);\n  removeClass(element, showClass);\n  addClass(element, collapsingClass);\n\n  reflow(element);\n  setElementStyle(element, { height: '0px' });\n\n  emulateTransitionEnd(element, () => {\n    Timer.clear(element);\n    /* istanbul ignore else */\n    if (parent) Timer.clear(parent);\n\n    triggers.forEach((btn) => setAttribute(btn, ariaExpanded, 'false'));\n\n    removeClass(element, collapsingClass);\n    addClass(element, collapseString);\n\n    setElementStyle(element, { height: '' });\n\n    dispatchEvent(element, hiddenCollapseEvent);\n  });\n}\n\n/**\n * Toggles on/off the event listener(s) of the `Collapse` instance.\n * @param {Collapse} self the `Collapse` instance\n * @param {boolean=} add when `true`, the event listener is added\n */\nfunction toggleCollapseHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { triggers } = self;\n\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach((btn) => action(btn, mouseclickEvent, collapseClickHandler));\n  }\n}\n\n// COLLAPSE EVENT HANDLER\n// ======================\n/**\n * Handles the `click` event for the `Collapse` instance.\n * @param {MouseEvent} e the `Event` object\n */\nfunction collapseClickHandler(e) {\n  const { target } = e; // our target is `HTMLElement`\n  const trigger = target && closest(target, collapseToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getCollapseInstance(element);\n  /* istanbul ignore else */\n  if (self) self.toggle();\n\n  // event target is anchor link #398\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n}\n\n// COLLAPSE DEFINITION\n// ===================\n\n/** Returns a new `Colapse` instance. */\nclass Collapse extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target and `Element` that matches the selector\n   * @param {BSN.Options.Collapse=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element, options } = self;\n    const doc = getDocument(element);\n\n    // set triggering elements\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(collapseToggleSelector, doc)]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // set parent accordion\n    /** @type {HTMLElement?} */\n    self.parent = querySelector(options.parent, doc)\n      || getTargetElement(element) || null;\n\n    // add event listeners\n    toggleCollapseHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return collapseComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return collapseDefaults; }\n  /* eslint-enable */\n\n  // COLLAPSE PUBLIC METHODS\n  // =======================\n  /** Toggles the visibility of the collapse. */\n  toggle() {\n    const self = this;\n    if (!hasClass(self.element, showClass)) self.show();\n    else self.hide();\n  }\n\n  /** Hides the collapse. */\n  hide() {\n    const self = this;\n    const { triggers, element } = self;\n    if (Timer.get(element)) return;\n\n    collapseContent(self);\n    /* istanbul ignore else */\n    if (triggers.length) {\n      triggers.forEach((btn) => addClass(btn, `${collapseString}d`));\n    }\n  }\n\n  /** Shows the collapse. */\n  show() {\n    const self = this;\n    const {\n      element, parent, triggers,\n    } = self;\n    let activeCollapse;\n    let activeCollapseInstance;\n\n    if (parent) {\n      activeCollapse = [...querySelectorAll(`.${collapseString}.${showClass}`, parent)]\n        .find((i) => getCollapseInstance(i));\n      activeCollapseInstance = activeCollapse && getCollapseInstance(activeCollapse);\n    }\n\n    if ((!parent || !Timer.get(parent)) && !Timer.get(element)) {\n      if (activeCollapseInstance && activeCollapse !== element) {\n        collapseContent(activeCollapseInstance);\n        activeCollapseInstance.triggers.forEach((btn) => {\n          addClass(btn, `${collapseString}d`);\n        });\n      }\n\n      expandCollapse(self);\n      /* istanbul ignore else */\n      if (triggers.length) {\n        triggers.forEach((btn) => removeClass(btn, `${collapseString}d`));\n      }\n    }\n  }\n\n  /** Remove the `Collapse` component from the target `Element`. */\n  dispose() {\n    const self = this;\n    toggleCollapseHandler(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Collapse, {\n  selector: collapseSelector,\n  init: collapseInitCallback,\n  getInstance: getCollapseInstance,\n});\n\n/**\n * A global namespace for `focus` event.\n * @type {string}\n */\nconst focusEvent = 'focus';\n\n/**\n * A global namespace for `keyup` event.\n * @type {string}\n */\nconst keyupEvent = 'keyup';\n\n/**\n * A global namespace for `scroll` event.\n * @type {string}\n */\nconst scrollEvent = 'scroll';\n\n/**\n * A global namespace for `resize` event.\n * @type {string}\n */\nconst resizeEvent = 'resize';\n\n/**\n * A global namespace for `ArrowUp` key.\n * @type {string} e.which = 38 equivalent\n */\nconst keyArrowUp = 'ArrowUp';\n\n/**\n * A global namespace for `ArrowDown` key.\n * @type {string} e.which = 40 equivalent\n */\nconst keyArrowDown = 'ArrowDown';\n\n/**\n * A global namespace for `Escape` key.\n * @type {string} e.which = 27 equivalent\n */\nconst keyEscape = 'Escape';\n\n/**\n * Shortcut for `HTMLElement.hasAttribute()` method.\n * @param  {HTMLElement} element target element\n * @param  {string} attribute attribute name\n * @returns {boolean} the query result\n */\nconst hasAttribute = (element, attribute) => element.hasAttribute(attribute);\n\n/**\n * Utility to focus an `HTMLElement` target.\n *\n * @param {HTMLElement} element is the target\n */\nconst focus = (element) => element.focus();\n\n/**\n * Returns the `Window` object of a target node.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {(Node | Window)=} node target node\n * @returns {Window} the `Window` object\n */\nfunction getWindow(node) {\n  // node is undefined | NULL\n  if (!node) return window;\n  // node instanceof Document\n  if (isDocument(node)) return node.defaultView;\n  // node instanceof Node\n  if (isNode(node)) return node.ownerDocument.defaultView;\n  // node is instanceof Window\n  return node;\n}\n\n/**\n * Global namespace for `Dropdown` types / classes.\n */\nconst dropdownMenuClasses = ['dropdown', 'dropup', 'dropstart', 'dropend'];\n\n/** @type {string} */\nconst dropdownComponent = 'Dropdown';\n\n/**\n * Global namespace for `.dropdown-menu`.\n */\nconst dropdownMenuClass = 'dropdown-menu';\n\n/**\n * Checks if an *event.target* or its parent has an `href=\"#\"` value.\n * We need to prevent jumping around onclick, don't we?\n *\n * @param {Node} element the target element\n * @returns {boolean} the query result\n */\nfunction isEmptyAnchor(element) {\n  // `EventTarget` must be `HTMLElement`\n  const parentAnchor = closest(element, 'A');\n  return isHTMLElement(element)\n    // anchor href starts with #\n    && ((hasAttribute(element, 'href') && element.href.slice(-1) === '#')\n    // OR a child of an anchor with href starts with #\n    || (parentAnchor && hasAttribute(parentAnchor, 'href')\n    && parentAnchor.href.slice(-1) === '#'));\n}\n\n/* Native JavaScript for Bootstrap 5 | Dropdown\n----------------------------------------------- */\n\n// DROPDOWN PRIVATE GC\n// ===================\nconst [\n  dropdownString,\n  dropupString,\n  dropstartString,\n  dropendString,\n] = dropdownMenuClasses;\nconst dropdownSelector = `[${dataBsToggle}=\"${dropdownString}\"]`;\n\n/**\n * Static method which returns an existing `Dropdown` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Dropdown>}\n */\nconst getDropdownInstance = (element) => getInstance(element, dropdownComponent);\n\n/**\n * A `Dropdown` initialization callback.\n * @type {BSN.InitCallback<Dropdown>}\n */\nconst dropdownInitCallback = (element) => new Dropdown(element);\n\n// DROPDOWN PRIVATE GC\n// ===================\n// const dropdownMenuStartClass = `${dropdownMenuClass}-start`;\nconst dropdownMenuEndClass = `${dropdownMenuClass}-end`;\nconst verticalClass = [dropdownString, dropupString];\nconst horizontalClass = [dropstartString, dropendString];\nconst menuFocusTags = ['A', 'BUTTON'];\n\nconst dropdownDefaults = {\n  offset: 5, // [number] 5(px)\n  display: 'dynamic', // [dynamic|static]\n};\n\n// DROPDOWN CUSTOM EVENTS\n// ======================\nconst showDropdownEvent = OriginalEvent(`show.bs.${dropdownString}`);\nconst shownDropdownEvent = OriginalEvent(`shown.bs.${dropdownString}`);\nconst hideDropdownEvent = OriginalEvent(`hide.bs.${dropdownString}`);\nconst hiddenDropdownEvent = OriginalEvent(`hidden.bs.${dropdownString}`);\n\n// DROPDOWN PRIVATE METHODS\n// ========================\n/**\n * Apply specific style or class names to a `.dropdown-menu` to automatically\n * accomodate the layout and the page scroll.\n *\n * @param {Dropdown} self the `Dropdown` instance\n */\nfunction styleDropdown(self) {\n  const {\n    element, menu, parentElement, options,\n  } = self;\n  const { offset } = options;\n\n  // don't apply any style on mobile view\n  /* istanbul ignore next: this test requires a navbar */\n  if (getElementStyle(menu, 'position') === 'static') return;\n\n  const RTL = isRTL(element);\n  // const menuStart = hasClass(menu, dropdownMenuStartClass);\n  const menuEnd = hasClass(menu, dropdownMenuEndClass);\n\n  // reset menu offset and position\n  const resetProps = ['margin', 'top', 'bottom', 'left', 'right'];\n  resetProps.forEach((p) => { menu.style[p] = ''; });\n\n  // set initial position class\n  // take into account .btn-group parent as .dropdown\n  // this requires navbar/btn-group/input-group\n  let positionClass = dropdownMenuClasses.find((c) => hasClass(parentElement, c))\n    || /* istanbul ignore next: fallback position */ dropdownString;\n\n  /** @type {Record<string, Record<string, any>>} */\n  let dropdownMargin = {\n    dropdown: [offset, 0, 0],\n    dropup: [0, 0, offset],\n    dropstart: RTL ? [-1, 0, 0, offset] : [-1, offset, 0],\n    dropend: RTL ? [-1, offset, 0] : [-1, 0, 0, offset],\n  };\n\n  /** @type {Record<string, Record<string, any>>} */\n  const dropdownPosition = {\n    dropdown: { top: '100%' },\n    dropup: { top: 'auto', bottom: '100%' },\n    dropstart: RTL ? { left: '100%', right: 'auto' } : { left: 'auto', right: '100%' },\n    dropend: RTL ? { left: 'auto', right: '100%' } : { left: '100%', right: 'auto' },\n    menuStart: RTL ? { right: 0, left: 'auto' } : { right: 'auto', left: 0 },\n    menuEnd: RTL ? { right: 'auto', left: 0 } : { right: 0, left: 'auto' },\n  };\n\n  const { offsetWidth: menuWidth, offsetHeight: menuHeight } = menu;\n\n  const { clientWidth, clientHeight } = getDocumentElement(element);\n  const {\n    left: targetLeft, top: targetTop,\n    width: targetWidth, height: targetHeight,\n  } = getBoundingClientRect(element);\n\n  // dropstart | dropend\n  const leftFullExceed = targetLeft - menuWidth - offset < 0;\n  // dropend\n  const rightFullExceed = targetLeft + menuWidth + targetWidth + offset >= clientWidth;\n  // dropstart | dropend\n  const bottomExceed = targetTop + menuHeight + offset >= clientHeight;\n  // dropdown\n  const bottomFullExceed = targetTop + menuHeight + targetHeight + offset >= clientHeight;\n  // dropup\n  const topExceed = targetTop - menuHeight - offset < 0;\n  // dropdown / dropup\n  const leftExceed = ((!RTL && menuEnd) || (RTL && !menuEnd))\n    && targetLeft + targetWidth - menuWidth < 0;\n  const rightExceed = ((RTL && menuEnd) || (!RTL && !menuEnd))\n    && targetLeft + menuWidth >= clientWidth;\n\n  // recompute position\n  // handle RTL as well\n  if (horizontalClass.includes(positionClass) && leftFullExceed && rightFullExceed) {\n    positionClass = dropdownString;\n  }\n  if (positionClass === dropstartString && (!RTL ? leftFullExceed : rightFullExceed)) {\n    positionClass = dropendString;\n  }\n  if (positionClass === dropendString && (RTL ? leftFullExceed : rightFullExceed)) {\n    positionClass = dropstartString;\n  }\n  if (positionClass === dropupString && topExceed && !bottomFullExceed) {\n    positionClass = dropdownString;\n  }\n  if (positionClass === dropdownString && bottomFullExceed && !topExceed) {\n    positionClass = dropupString;\n  }\n\n  // override position for horizontal classes\n  if (horizontalClass.includes(positionClass) && bottomExceed) {\n    ObjectAssign(dropdownPosition[positionClass], {\n      top: 'auto', bottom: 0,\n    });\n  }\n\n  // override position for vertical classes\n  if (verticalClass.includes(positionClass) && (leftExceed || rightExceed)) {\n    // don't realign when menu is wider than window\n    // in both RTL and non-RTL readability is KING\n    let posAjust;\n    if (!leftExceed && rightExceed && !RTL) posAjust = { left: 'auto', right: 0 };\n    if (leftExceed && !rightExceed && RTL) posAjust = { left: 0, right: 'auto' };\n    if (posAjust) ObjectAssign(dropdownPosition[positionClass], posAjust);\n  }\n\n  dropdownMargin = dropdownMargin[positionClass];\n  setElementStyle(menu, {\n    ...dropdownPosition[positionClass],\n    margin: `${dropdownMargin.map((x) => (x ? `${x}px` : x)).join(' ')}`,\n  });\n\n  // override dropdown-menu-start | dropdown-menu-end\n  if (verticalClass.includes(positionClass) && menuEnd) {\n    /* istanbul ignore else */\n    if (menuEnd) {\n      const endAdjust = (!RTL && leftExceed) || (RTL && rightExceed)\n        ? 'menuStart' : /* istanbul ignore next */'menuEnd';\n      setElementStyle(menu, dropdownPosition[endAdjust]);\n    }\n  }\n}\n\n/**\n * Returns an `Array` of focusable items in the given dropdown-menu.\n * @param {HTMLElement} menu\n * @returns {HTMLElement[]}\n */\nfunction getMenuItems(menu) {\n  return [...menu.children].map((c) => {\n    if (c && menuFocusTags.includes(c.tagName)) return c;\n    const { firstElementChild } = c;\n    if (firstElementChild && menuFocusTags.includes(firstElementChild.tagName)) {\n      return firstElementChild;\n    }\n    return null;\n  }).filter((c) => c);\n}\n\n/**\n * Toggles on/off the listeners for the events that close the dropdown\n * as well as event that request a new position for the dropdown.\n *\n * @param {Dropdown} self the `Dropdown` instance\n */\nfunction toggleDropdownDismiss(self) {\n  const { element, options } = self;\n  const action = self.open ? addListener : removeListener;\n  const doc = getDocument(element);\n\n  action(doc, mouseclickEvent, dropdownDismissHandler);\n  action(doc, focusEvent, dropdownDismissHandler);\n  action(doc, keydownEvent, dropdownPreventScroll);\n  action(doc, keyupEvent, dropdownKeyHandler);\n\n  /* istanbul ignore else */\n  if (options.display === 'dynamic') {\n    [scrollEvent, resizeEvent].forEach((ev) => {\n      action(getWindow(element), ev, dropdownLayoutHandler, passiveHandler);\n    });\n  }\n}\n\n/**\n * Toggles on/off the `click` event listener of the `Dropdown`.\n *\n * @param {Dropdown} self the `Dropdown` instance\n * @param {boolean=} add when `true`, it will add the event listener\n */\nfunction toggleDropdownHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, dropdownClickHandler);\n}\n\n/**\n * Returns the currently open `.dropdown` element.\n *\n * @param {(Node | Window)=} element target\n * @returns {HTMLElement?} the query result\n */\nfunction getCurrentOpenDropdown(element) {\n  const currentParent = [...dropdownMenuClasses, 'btn-group', 'input-group']\n    .map((c) => getElementsByClassName(`${c} ${showClass}`, getDocument(element)))\n    .find((x) => x.length);\n\n  if (currentParent && currentParent.length) {\n    return [...currentParent[0].children]\n      .find((x) => hasAttribute(x, dataBsToggle));\n  }\n  return null;\n}\n\n// DROPDOWN EVENT HANDLERS\n// =======================\n/**\n * Handles the `click` event for the `Dropdown` instance.\n *\n * @param {MouseEvent} e event object\n * @this {Document}\n */\nfunction dropdownDismissHandler(e) {\n  const { target, type } = e;\n\n  /* istanbul ignore next: impossible to satisfy */\n  if (!target || !target.closest) return; // some weird FF bug #409\n\n  const element = getCurrentOpenDropdown(target);\n  const self = getDropdownInstance(element);\n\n  /* istanbul ignore next */\n  if (!self) return;\n\n  const { parentElement, menu } = self;\n\n  const hasData = closest(target, dropdownSelector) !== null;\n  const isForm = parentElement && parentElement.contains(target)\n    && (target.tagName === 'form' || closest(target, 'form') !== null);\n\n  if (type === mouseclickEvent && isEmptyAnchor(target)) {\n    e.preventDefault();\n  }\n  if (type === focusEvent\n    && (target === element || target === menu || menu.contains(target))) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (isForm || hasData) ; else if (self) {\n    self.hide();\n  }\n}\n\n/**\n * Handles `click` event listener for `Dropdown`.\n * @this {HTMLElement}\n * @param {MouseEvent} e event object\n */\nfunction dropdownClickHandler(e) {\n  const element = this;\n  const { target } = e;\n  const self = getDropdownInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    self.toggle();\n    /* istanbul ignore else */\n    if (target && isEmptyAnchor(target)) e.preventDefault();\n  }\n}\n\n/**\n * Prevents scroll when dropdown-menu is visible.\n * @param {KeyboardEvent} e event object\n */\nfunction dropdownPreventScroll(e) {\n  /* istanbul ignore else */\n  if ([keyArrowDown, keyArrowUp].includes(e.code)) e.preventDefault();\n}\n\n/**\n * Handles keyboard `keydown` events for `Dropdown`.\n * @param {KeyboardEvent} e keyboard key\n * @this {Document}\n */\nfunction dropdownKeyHandler(e) {\n  const { code } = e;\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n  const { activeElement } = element && getDocument(element);\n  /* istanbul ignore next: impossible to satisfy */\n  if (!self || !activeElement) return;\n  const { menu, open } = self;\n  const menuItems = getMenuItems(menu);\n\n  // arrow up & down\n  if (menuItems && menuItems.length && [keyArrowDown, keyArrowUp].includes(code)) {\n    let idx = menuItems.indexOf(activeElement);\n    /* istanbul ignore else */\n    if (activeElement === element) {\n      idx = 0;\n    } else if (code === keyArrowUp) {\n      idx = idx > 1 ? idx - 1 : 0;\n    } else if (code === keyArrowDown) {\n      idx = idx < menuItems.length - 1 ? idx + 1 : idx;\n    }\n    /* istanbul ignore else */\n    if (menuItems[idx]) focus(menuItems[idx]);\n  }\n\n  if (keyEscape === code && open) {\n    self.toggle();\n    focus(element);\n  }\n}\n\n/**\n * @this {globalThis}\n * @returns {void}\n */\nfunction dropdownLayoutHandler() {\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n\n  /* istanbul ignore else */\n  if (self && self.open) styleDropdown(self);\n}\n\n// DROPDOWN DEFINITION\n// ===================\n/** Returns a new Dropdown instance. */\nclass Dropdown extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target Element or string selector\n   * @param {BSN.Options.Dropdown=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n    const { parentElement } = element;\n\n    // set targets\n    /** @type {(Element | HTMLElement)} */\n    self.parentElement = parentElement;\n    /** @type {(Element | HTMLElement)} */\n    self.menu = querySelector(`.${dropdownMenuClass}`, parentElement);\n\n    // set initial state to closed\n    /** @type {boolean} */\n    self.open = false;\n\n    // add event listener\n    toggleDropdownHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return dropdownComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return dropdownDefaults; }\n  /* eslint-enable */\n\n  // DROPDOWN PUBLIC METHODS\n  // =======================\n  /** Shows/hides the dropdown menu to the user. */\n  toggle() {\n    const self = this;\n\n    if (self.open) self.hide();\n    else self.show();\n  }\n\n  /** Shows the dropdown menu to the user. */\n  show() {\n    const self = this;\n    const {\n      element, open, menu, parentElement,\n    } = self;\n\n    /* istanbul ignore next */\n    if (open) return;\n\n    const currentElement = getCurrentOpenDropdown(element);\n    const currentInstance = currentElement && getDropdownInstance(currentElement);\n    if (currentInstance) currentInstance.hide();\n\n    // dispatch event\n    [showDropdownEvent, shownDropdownEvent].forEach((e) => {\n      e.relatedTarget = element;\n    });\n    dispatchEvent(parentElement, showDropdownEvent);\n    if (showDropdownEvent.defaultPrevented) return;\n\n    addClass(menu, showClass);\n    addClass(parentElement, showClass);\n    setAttribute(element, ariaExpanded, 'true');\n\n    // change menu position\n    styleDropdown(self);\n\n    self.open = !open;\n\n    focus(element); // focus the element\n    toggleDropdownDismiss(self);\n    dispatchEvent(parentElement, shownDropdownEvent);\n  }\n\n  /** Hides the dropdown menu from the user. */\n  hide() {\n    const self = this;\n    const {\n      element, open, menu, parentElement,\n    } = self;\n\n    /* istanbul ignore next */\n    if (!open) return;\n\n    [hideDropdownEvent, hiddenDropdownEvent].forEach((e) => {\n      e.relatedTarget = element;\n    });\n    dispatchEvent(parentElement, hideDropdownEvent);\n    if (hideDropdownEvent.defaultPrevented) return;\n\n    removeClass(menu, showClass);\n    removeClass(parentElement, showClass);\n    setAttribute(element, ariaExpanded, 'false');\n\n    self.open = !open;\n    // only re-attach handler if the instance is not disposed\n    toggleDropdownDismiss(self);\n    dispatchEvent(parentElement, hiddenDropdownEvent);\n  }\n\n  /** Removes the `Dropdown` component from the target element. */\n  dispose() {\n    const self = this;\n    if (self.open) self.hide();\n\n    toggleDropdownHandler(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Dropdown, {\n  selector: dropdownSelector,\n  init: dropdownInitCallback,\n  getInstance: getDropdownInstance,\n});\n\n/**\n * A global namespace for aria-hidden.\n * @type {string}\n */\nconst ariaHidden = 'aria-hidden';\n\n/**\n * A global namespace for aria-modal.\n * @type {string}\n */\nconst ariaModal = 'aria-modal';\n\n/**\n * Shortcut for `HTMLElement.removeAttribute()` method.\n * @param  {HTMLElement} element target element\n * @param  {string} attribute attribute name\n * @returns {void}\n */\nconst removeAttribute = (element, attribute) => element.removeAttribute(attribute);\n\n/**\n * Returns the `document.body` or the `<body>` element.\n *\n * @param {(Node | Window)=} node\n * @returns {HTMLBodyElement}\n */\nfunction getDocumentBody(node) {\n  return getDocument(node).body;\n}\n\n/** @type {string} */\nconst modalString = 'modal';\n\n/** @type {string} */\nconst modalComponent = 'Modal';\n\n/**\n * Check if target is a `ShadowRoot`.\n *\n * @param {any} element target\n * @returns {boolean} the query result\n */\nconst isShadowRoot = (element) => (element && element.constructor.name === 'ShadowRoot')\n  || false;\n\n/**\n * Returns the `parentNode` also going through `ShadowRoot`.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {Node} node the target node\n * @returns {Node} the apropriate parent node\n */\nfunction getParentNode(node) {\n  if (node.nodeName === 'HTML') {\n    return node;\n  }\n\n  // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n  return (\n    node.assignedSlot // step into the shadow DOM of the parent of a slotted node\n    || node.parentNode // DOM Element detected\n    || (isShadowRoot(node) && node.host) // ShadowRoot detected\n    || getDocumentElement(node) // fallback\n  );\n}\n\n/**\n * Check if a target element is a `<table>`, `<td>` or `<th>`.\n * This specific check is important for determining\n * the `offsetParent` of a given element.\n *\n * @param {any} element the target element\n * @returns {boolean} the query result\n */\nconst isTableElement = (element) => (element && ['TABLE', 'TD', 'TH'].includes(element.tagName))\n  || false;\n\n/**\n * Returns an `HTMLElement` to be used as default value for *options.container*\n * for `Tooltip` / `Popover` components.\n *\n * When `getOffset` is *true*, it returns the `offsetParent` for tooltip/popover\n * offsets computation similar to **floating-ui**.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element the target\n * @param {boolean=} getOffset when *true* it will return an `offsetParent`\n * @returns {ParentNode | Window} the query result\n */\nfunction getElementContainer(element, getOffset) {\n  const majorBlockTags = ['HTML', 'BODY'];\n\n  if (getOffset) {\n    /** @type {any} */\n    let { offsetParent } = element;\n    const win = getWindow(element);\n\n    while (offsetParent && (isTableElement(offsetParent)\n      || (isHTMLElement(offsetParent)\n        // we must count for both fixed & sticky\n        && !['sticky', 'fixed'].includes(getElementStyle(offsetParent, 'position'))))) {\n      offsetParent = offsetParent.offsetParent;\n    }\n\n    if (!offsetParent || (majorBlockTags.includes(offsetParent.tagName)\n        || getElementStyle(offsetParent, 'position') === 'static')) {\n      offsetParent = win;\n    }\n    return offsetParent;\n  }\n\n  /** @type {ParentNode[]} */\n  const containers = [];\n  /** @type {ParentNode} */\n  let { parentNode } = element;\n\n  while (parentNode && !majorBlockTags.includes(parentNode.nodeName)) {\n    parentNode = getParentNode(parentNode);\n    /* istanbul ignore else */\n    if (!(isShadowRoot(parentNode) || !!parentNode.shadowRoot\n      || isTableElement(parentNode))) {\n      containers.push(parentNode);\n    }\n  }\n\n  return containers.find((c, i) => {\n    if (getElementStyle(c, 'position') !== 'relative'\n      && containers.slice(i + 1).every((r) => getElementStyle(r, 'position') === 'static')) {\n      return c;\n    }\n    return null;\n  }) || getDocumentBody(element);\n}\n\n/**\n * Global namespace for components `fixed-top` class.\n */\nconst fixedTopClass = 'fixed-top';\n\n/**\n * Global namespace for components `fixed-bottom` class.\n */\nconst fixedBottomClass = 'fixed-bottom';\n\n/**\n * Global namespace for components `sticky-top` class.\n */\nconst stickyTopClass = 'sticky-top';\n\n/**\n * Global namespace for components `position-sticky` class.\n */\nconst positionStickyClass = 'position-sticky';\n\n/** @param {(HTMLElement | Document)=} parent */\nconst getFixedItems = (parent) => [\n  ...getElementsByClassName(fixedTopClass, parent),\n  ...getElementsByClassName(fixedBottomClass, parent),\n  ...getElementsByClassName(stickyTopClass, parent),\n  ...getElementsByClassName(positionStickyClass, parent),\n  ...getElementsByClassName('is-fixed', parent),\n];\n\n/**\n * Removes *padding* and *overflow* from the `<body>`\n * and all spacing from fixed items.\n * @param {HTMLElement=} element the target modal/offcanvas\n */\nfunction resetScrollbar(element) {\n  const bd = getDocumentBody(element);\n  setElementStyle(bd, {\n    paddingRight: '',\n    overflow: '',\n  });\n\n  const fixedItems = getFixedItems(bd);\n\n  if (fixedItems.length) {\n    fixedItems.forEach((fixed) => {\n      setElementStyle(fixed, {\n        paddingRight: '',\n        marginRight: '',\n      });\n    });\n  }\n}\n\n/**\n * Returns the scrollbar width if the body does overflow\n * the window.\n * @param {HTMLElement=} element\n * @returns {number} the value\n */\nfunction measureScrollbar(element) {\n  const { clientWidth } = getDocumentElement(element);\n  const { innerWidth } = getWindow(element);\n  return Math.abs(innerWidth - clientWidth);\n}\n\n/**\n * Sets the `<body>` and fixed items style when modal / offcanvas\n * is shown to the user.\n *\n * @param {HTMLElement} element the target modal/offcanvas\n * @param {boolean=} overflow body does overflow or not\n */\nfunction setScrollbar(element, overflow) {\n  const bd = getDocumentBody(element);\n  const bodyPad = parseInt(getElementStyle(bd, 'paddingRight'), 10);\n  const isOpen = getElementStyle(bd, 'overflow') === 'hidden';\n  const sbWidth = isOpen && bodyPad ? 0 : measureScrollbar(element);\n  const fixedItems = getFixedItems(bd);\n\n  /* istanbul ignore else */\n  if (overflow) {\n    setElementStyle(bd, {\n      overflow: 'hidden',\n      paddingRight: `${bodyPad + sbWidth}px`,\n    });\n\n    /* istanbul ignore else */\n    if (fixedItems.length) {\n      fixedItems.forEach((fixed) => {\n        const itemPadValue = getElementStyle(fixed, 'paddingRight');\n        fixed.style.paddingRight = `${parseInt(itemPadValue, 10) + sbWidth}px`;\n        /* istanbul ignore else */\n        if ([stickyTopClass, positionStickyClass].some((c) => hasClass(fixed, c))) {\n          const itemMValue = getElementStyle(fixed, 'marginRight');\n          fixed.style.marginRight = `${parseInt(itemMValue, 10) - sbWidth}px`;\n        }\n      });\n    }\n  }\n}\n\n/**\n * This is a shortie for `document.createElement` method\n * which allows you to create a new `HTMLElement` for a given `tagName`\n * or based on an object with specific non-readonly attributes:\n * `id`, `className`, `textContent`, `style`, etc.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement\n *\n * @param {Record<string, string> | string} param `tagName` or object\n * @return {HTMLElement} a new `HTMLElement` or `Element`\n */\nfunction createElement(param) {\n  if (!param) return null;\n\n  if (typeof param === 'string') {\n    return getDocument().createElement(param);\n  }\n\n  const { tagName } = param;\n  const attr = { ...param };\n  const newElement = createElement(tagName);\n  delete attr.tagName;\n  ObjectAssign(newElement, attr);\n  return newElement;\n}\n\n/** @type {string} */\nconst offcanvasString = 'offcanvas';\n\nconst backdropString = 'backdrop';\nconst modalBackdropClass = `${modalString}-${backdropString}`;\nconst offcanvasBackdropClass = `${offcanvasString}-${backdropString}`;\nconst modalActiveSelector = `.${modalString}.${showClass}`;\nconst offcanvasActiveSelector = `.${offcanvasString}.${showClass}`;\n\n// any document would suffice\nconst overlay = createElement('div');\n\n/**\n * Returns the current active modal / offcancas element.\n * @param {HTMLElement=} element the context element\n * @returns {HTMLElement?} the requested element\n */\nfunction getCurrentOpen(element) {\n  return querySelector(`${modalActiveSelector},${offcanvasActiveSelector}`, getDocument(element));\n}\n\n/**\n * Toogles from a Modal overlay to an Offcanvas, or vice-versa.\n * @param {boolean=} isModal\n */\nfunction toggleOverlayType(isModal) {\n  const targetClass = isModal ? modalBackdropClass : offcanvasBackdropClass;\n  [modalBackdropClass, offcanvasBackdropClass].forEach((c) => {\n    removeClass(overlay, c);\n  });\n  addClass(overlay, targetClass);\n}\n\n/**\n * Append the overlay to DOM.\n * @param {HTMLElement} container\n * @param {boolean} hasFade\n * @param {boolean=} isModal\n */\nfunction appendOverlay(container, hasFade, isModal) {\n  toggleOverlayType(isModal);\n  container.append(overlay);\n  if (hasFade) addClass(overlay, fadeClass);\n}\n\n/**\n * Shows the overlay to the user.\n */\nfunction showOverlay() {\n  if (!hasClass(overlay, showClass)) {\n    addClass(overlay, showClass);\n    reflow(overlay);\n  }\n}\n\n/**\n * Hides the overlay from the user.\n */\nfunction hideOverlay() {\n  removeClass(overlay, showClass);\n}\n\n/**\n * Removes the overlay from DOM.\n * @param {HTMLElement=} element\n */\nfunction removeOverlay(element) {\n  if (!getCurrentOpen(element)) {\n    removeClass(overlay, fadeClass);\n    overlay.remove();\n    resetScrollbar(element);\n  }\n}\n\n/**\n * @param {HTMLElement} element target\n * @returns {boolean}\n */\nfunction isVisible(element) {\n  return isHTMLElement(element)\n    && getElementStyle(element, 'visibility') !== 'hidden'\n    && element.offsetParent !== null;\n}\n\n/* Native JavaScript for Bootstrap 5 | Modal\n-------------------------------------------- */\n\n// MODAL PRIVATE GC\n// ================\nconst modalSelector = `.${modalString}`;\nconst modalToggleSelector = `[${dataBsToggle}=\"${modalString}\"]`;\nconst modalDismissSelector = `[${dataBsDismiss}=\"${modalString}\"]`;\nconst modalStaticClass = `${modalString}-static`;\n\nconst modalDefaults = {\n  backdrop: true, // boolean|string\n  keyboard: true, // boolean\n};\n\n/**\n * Static method which returns an existing `Modal` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Modal>}\n */\nconst getModalInstance = (element) => getInstance(element, modalComponent);\n\n/**\n * A `Modal` initialization callback.\n * @type {BSN.InitCallback<Modal>}\n */\nconst modalInitCallback = (element) => new Modal(element);\n\n// MODAL CUSTOM EVENTS\n// ===================\nconst showModalEvent = OriginalEvent(`show.bs.${modalString}`);\nconst shownModalEvent = OriginalEvent(`shown.bs.${modalString}`);\nconst hideModalEvent = OriginalEvent(`hide.bs.${modalString}`);\nconst hiddenModalEvent = OriginalEvent(`hidden.bs.${modalString}`);\n\n// MODAL PRIVATE METHODS\n// =====================\n/**\n * Applies special style for the `<body>` and fixed elements\n * when a modal instance is shown to the user.\n *\n * @param {Modal} self the `Modal` instance\n */\nfunction setModalScrollbar(self) {\n  const { element } = self;\n  const scrollbarWidth = measureScrollbar(element);\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  const { clientHeight: modalHeight, scrollHeight: modalScrollHeight } = element;\n  const modalOverflow = modalHeight !== modalScrollHeight;\n\n  /* istanbul ignore else */\n  if (!modalOverflow && scrollbarWidth) {\n    const pad = !isRTL(element) ? 'paddingRight' : /* istanbul ignore next */'paddingLeft';\n    const padStyle = {};\n    padStyle[pad] = `${scrollbarWidth}px`;\n    setElementStyle(element, padStyle);\n  }\n  setScrollbar(element, (modalOverflow || clientHeight !== scrollHeight));\n}\n\n/**\n * Toggles on/off the listeners of events that close the modal.\n *\n * @param {Modal} self the `Modal` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleModalDismiss(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n  action(element, mouseclickEvent, modalDismissHandler);\n  action(getWindow(element), resizeEvent, self.update, passiveHandler);\n  action(getDocument(element), keydownEvent, modalKeyHandler);\n}\n\n/**\n * Toggles on/off the `click` event listener of the `Modal` instance.\n * @param {Modal} self the `Modal` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleModalHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { triggers } = self;\n\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach((btn) => action(btn, mouseclickEvent, modalClickHandler));\n  }\n}\n\n/**\n * Executes after a modal is hidden to the user.\n * @param {Modal} self the `Modal` instance\n * @param {Function} callback the `Modal` instance\n */\nfunction afterModalHide(self, callback) {\n  const { triggers, element, relatedTarget } = self;\n  removeOverlay(element);\n  setElementStyle(element, { paddingRight: '', display: '' });\n  toggleModalDismiss(self);\n\n  const focusElement = showModalEvent.relatedTarget || triggers.find(isVisible);\n  /* istanbul ignore else */\n  if (focusElement) focus(focusElement);\n\n  /* istanbul ignore else */\n  if (callback) callback();\n\n  hiddenModalEvent.relatedTarget = relatedTarget;\n  dispatchEvent(element, hiddenModalEvent);\n}\n\n/**\n * Executes after a modal is shown to the user.\n * @param {Modal} self the `Modal` instance\n */\nfunction afterModalShow(self) {\n  const { element, relatedTarget } = self;\n  focus(element);\n  toggleModalDismiss(self, true);\n\n  shownModalEvent.relatedTarget = relatedTarget;\n  dispatchEvent(element, shownModalEvent);\n}\n\n/**\n * Executes before a modal is shown to the user.\n * @param {Modal} self the `Modal` instance\n */\nfunction beforeModalShow(self) {\n  const { element, hasFade } = self;\n  setElementStyle(element, { display: 'block' });\n\n  setModalScrollbar(self);\n  /* istanbul ignore else */\n  if (!getCurrentOpen(element)) {\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, showClass);\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n\n  if (hasFade) emulateTransitionEnd(element, () => afterModalShow(self));\n  else afterModalShow(self);\n}\n\n/**\n * Executes before a modal is hidden to the user.\n * @param {Modal} self the `Modal` instance\n * @param {Function=} callback when `true` skip animation\n */\nfunction beforeModalHide(self, callback) {\n  const {\n    element, options, hasFade,\n  } = self;\n\n  // callback can also be the transitionEvent object, we wanna make sure it's not\n  // call is not forced and overlay is visible\n  if (options.backdrop && !callback && hasFade && hasClass(overlay, showClass)\n    && !getCurrentOpen(element)) { // AND no modal is visible\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => afterModalHide(self));\n  } else {\n    afterModalHide(self, callback);\n  }\n}\n\n// MODAL EVENT HANDLERS\n// ====================\n/**\n * Handles the `click` event listener for modal.\n * @param {MouseEvent} e the `Event` object\n */\nfunction modalClickHandler(e) {\n  const { target } = e;\n\n  const trigger = target && closest(target, modalToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getModalInstance(element);\n\n  /* istanbul ignore else */\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n  self.relatedTarget = trigger;\n  self.toggle();\n}\n\n/**\n * Handles the `keydown` event listener for modal\n * to hide the modal when user type the `ESC` key.\n *\n * @param {KeyboardEvent} e the `Event` object\n */\nfunction modalKeyHandler({ code, target }) {\n  const element = querySelector(modalActiveSelector, getDocument(target));\n  const self = element && getModalInstance(element);\n\n  const { options } = self;\n  /* istanbul ignore else */\n  if (options.keyboard && code === keyEscape // the keyboard option is enabled and the key is 27\n    && hasClass(element, showClass)) { // the modal is not visible\n    self.relatedTarget = null;\n    self.hide();\n  }\n}\n\n/**\n * Handles the `click` event listeners that hide the modal.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction modalDismissHandler(e) {\n  const element = this;\n  const self = getModalInstance(element);\n\n  // this timer is needed\n  /* istanbul ignore next: must have a filter */\n  if (!self || Timer.get(element)) return;\n\n  const { options, isStatic, modalDialog } = self;\n  const { backdrop } = options;\n  const { target } = e;\n\n  const selectedText = getDocument(element).getSelection().toString().length;\n  const targetInsideDialog = modalDialog.contains(target);\n  const dismiss = target && closest(target, modalDismissSelector);\n\n  /* istanbul ignore else */\n  if (isStatic && !targetInsideDialog) {\n    Timer.set(element, () => {\n      addClass(element, modalStaticClass);\n      emulateTransitionEnd(modalDialog, () => staticTransitionEnd(self));\n    }, 17);\n  } else if (dismiss || (!selectedText && !isStatic && !targetInsideDialog && backdrop)) {\n    self.relatedTarget = dismiss || null;\n    self.hide();\n    e.preventDefault();\n  }\n}\n\n/**\n * Handles the `transitionend` event listeners for `Modal`.\n *\n * @param {Modal} self the `Modal` instance\n */\nfunction staticTransitionEnd(self) {\n  const { element, modalDialog } = self;\n  const duration = getElementTransitionDuration(modalDialog) + 17;\n  removeClass(element, modalStaticClass);\n  // user must wait for zoom out transition\n  Timer.set(element, () => Timer.clear(element), duration);\n}\n\n// MODAL DEFINITION\n// ================\n/** Returns a new `Modal` instance. */\nclass Modal extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target usually the `.modal` element\n   * @param {BSN.Options.Modal=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n\n    // bind\n    const self = this;\n\n    // the modal\n    const { element } = self;\n\n    // the modal-dialog\n    /** @type {(HTMLElement)} */\n    self.modalDialog = querySelector(`.${modalString}-dialog`, element);\n\n    // modal can have multiple triggering elements\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(modalToggleSelector, getDocument(element))]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // additional internals\n    /** @type {boolean} */\n    self.isStatic = self.options.backdrop === 'static';\n    /** @type {boolean} */\n    self.hasFade = hasClass(element, fadeClass);\n    /** @type {HTMLElement?} */\n    self.relatedTarget = null;\n    /** @type {HTMLBodyElement | HTMLElement} */\n    self.container = getElementContainer(element);\n\n    // attach event listeners\n    toggleModalHandler(self, true);\n\n    // bind\n    self.update = self.update.bind(self);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return modalComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return modalDefaults; }\n  /* eslint-enable */\n\n  // MODAL PUBLIC METHODS\n  // ====================\n  /** Toggles the visibility of the modal. */\n  toggle() {\n    const self = this;\n    if (hasClass(self.element, showClass)) self.hide();\n    else self.show();\n  }\n\n  /** Shows the modal to the user. */\n  show() {\n    const self = this;\n    const {\n      element, options, hasFade, relatedTarget, container,\n    } = self;\n    const { backdrop } = options;\n    let overlayDelay = 0;\n\n    if (hasClass(element, showClass)) return;\n\n    showModalEvent.relatedTarget = relatedTarget || null;\n    dispatchEvent(element, showModalEvent);\n    if (showModalEvent.defaultPrevented) return;\n\n    // we elegantly hide any opened modal/offcanvas\n    const currentOpen = getCurrentOpen(element);\n    if (currentOpen && currentOpen !== element) {\n      const this1 = getModalInstance(currentOpen);\n      const that1 = this1\n        || /* istanbul ignore next */getInstance(currentOpen, 'Offcanvas');\n      that1.hide();\n    }\n\n    if (backdrop) {\n      if (!container.contains(overlay)) {\n        appendOverlay(container, hasFade, true);\n      } else {\n        toggleOverlayType(true);\n      }\n\n      overlayDelay = getElementTransitionDuration(overlay);\n\n      showOverlay();\n      setTimeout(() => beforeModalShow(self), overlayDelay);\n    } else {\n      beforeModalShow(self);\n      /* istanbul ignore else */\n      if (currentOpen && hasClass(overlay, showClass)) {\n        hideOverlay();\n      }\n    }\n  }\n\n  /**\n   * Hide the modal from the user.\n   * @param {Function=} callback when defined it will skip animation\n   */\n  hide(callback) {\n    const self = this;\n    const {\n      element, hasFade, relatedTarget,\n    } = self;\n\n    if (!hasClass(element, showClass)) return;\n\n    hideModalEvent.relatedTarget = relatedTarget || null;\n    dispatchEvent(element, hideModalEvent);\n    if (hideModalEvent.defaultPrevented) return;\n    removeClass(element, showClass);\n    setAttribute(element, ariaHidden, 'true');\n    removeAttribute(element, ariaModal);\n\n    // if (hasFade && callback) {\n    /* istanbul ignore else */\n    if (hasFade) {\n      emulateTransitionEnd(element, () => beforeModalHide(self, callback));\n    } else {\n      beforeModalHide(self, callback);\n    }\n  }\n\n  /**\n   * Updates the modal layout.\n   * @this {Modal} the modal instance\n   */\n  update() {\n    const self = this;\n    /* istanbul ignore else */\n    if (hasClass(self.element, showClass)) setModalScrollbar(self);\n  }\n\n  /** Removes the `Modal` component from target element. */\n  dispose() {\n    const self = this;\n    toggleModalHandler(self);\n    // use callback\n    self.hide(() => super.dispose());\n  }\n}\n\nObjectAssign(Modal, {\n  selector: modalSelector,\n  init: modalInitCallback,\n  getInstance: getModalInstance,\n});\n\n/** @type {string} */\nconst offcanvasComponent = 'Offcanvas';\n\n/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Offcanvas>}\n */\nconst getOffcanvasInstance = (element) => getInstance(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n * @type {BSN.InitCallback<Offcanvas>}\n */\nconst offcanvasInitCallback = (element) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = OriginalEvent(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = OriginalEvent(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = OriginalEvent(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = OriginalEvent(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction setOffCanvasScrollbar(self) {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n}\n\n/**\n * Toggles on/off the `click` event listeners.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {boolean=} add when *true*, listeners are added\n */\nfunction toggleOffcanvasEvents(self, add) {\n  const action = add ? addListener : removeListener;\n  self.triggers.forEach((btn) => action(btn, mouseclickEvent, offcanvasTriggerHandler));\n}\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {boolean=} add when *true* listeners are added\n */\nfunction toggleOffCanvasDismiss(self, add) {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler);\n  action(doc, mouseclickEvent, offcanvasDismissHandler);\n}\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction beforeOffcanvasShow(self) {\n  const { element, options } = self;\n\n  /* istanbul ignore else */\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: 'visible' });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n}\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {Function=} callback the hide callback\n */\nfunction beforeOffcanvasHide(self, callback) {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  element.blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => hideOffcanvasComplete(self, callback));\n  } else hideOffcanvasComplete(self, callback);\n}\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction offcanvasTriggerHandler(e) {\n  const trigger = closest(this, offcanvasToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    self.relatedTarget = trigger;\n    self.toggle();\n    /* istanbul ignore else */\n    if (trigger && trigger.tagName === 'A') {\n      e.preventDefault();\n    }\n  }\n}\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param {MouseEvent} e the `Event` object\n */\nfunction offcanvasDismissHandler(e) {\n  const { target } = e;\n  const element = querySelector(offcanvasActiveSelector, getDocument(target));\n  const offCanvasDismiss = querySelector(offcanvasDismissSelector, element);\n  const self = getOffcanvasInstance(element);\n\n  /* istanbul ignore next: must have a filter */\n  if (!self) return;\n\n  const { options, triggers } = self;\n  const { backdrop } = options;\n  const trigger = closest(target, offcanvasToggleSelector);\n  const selection = getDocument(element).getSelection();\n\n  if (overlay.contains(target) && backdrop === 'static') return;\n\n  /* istanbul ignore else */\n  if (!(selection && selection.toString().length)\n    && ((!element.contains(target) && backdrop\n    && /* istanbul ignore next */(!trigger || triggers.includes(target)))\n    || (offCanvasDismiss && offCanvasDismiss.contains(target)))) {\n    self.relatedTarget = offCanvasDismiss && offCanvasDismiss.contains(target)\n      ? offCanvasDismiss : null;\n    self.hide();\n  }\n\n  /* istanbul ignore next */\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n}\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param {KeyboardEvent} e the `Event` object\n */\nfunction offcanvasKeyDismissHandler({ code, target }) {\n  const element = querySelector(offcanvasActiveSelector, getDocument(target));\n\n  const self = getOffcanvasInstance(element);\n\n  /* istanbul ignore next: must filter */\n  if (!self) return;\n\n  /* istanbul ignore else */\n  if (self.options.keyboard && code === keyEscape) {\n    self.relatedTarget = null;\n    self.hide();\n  }\n}\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction showOffcanvasComplete(self) {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n  setAttribute(element, 'role', 'dialog');\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n}\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {Function} callback the hide callback\n */\nfunction hideOffcanvasComplete(self, callback) {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, 'true');\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, 'role');\n  setElementStyle(element, { visibility: '' });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget || triggers.find((x) => isVisible(x));\n  /* istanbul ignore else */\n  if (visibleTrigger) focus(visibleTrigger);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n  // callback\n  if (callback) callback();\n}\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nclass Offcanvas extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target usually an `.offcanvas` element\n   * @param {BSN.Options.Offcanvas=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    const self = this;\n\n    // instance element\n    const { element } = self;\n\n    // all the triggering buttons\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(offcanvasToggleSelector, getDocument(element))]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // additional instance property\n    /** @type {HTMLBodyElement | HTMLElement} */\n    self.container = getElementContainer(element);\n    /** @type {HTMLElement?} */\n    self.relatedTarget = null;\n\n    // attach event listeners\n    toggleOffcanvasEvents(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return offcanvasComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return offcanvasDefaults; }\n  /* eslint-enable */\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    const self = this;\n    if (hasClass(self.element, showClass)) self.hide();\n    else self.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const self = this;\n    const {\n      element, options, container, relatedTarget,\n    } = self;\n    let overlayDelay = 0;\n\n    if (hasClass(element, showClass)) return;\n\n    showOffcanvasEvent.relatedTarget = relatedTarget;\n    shownOffcanvasEvent.relatedTarget = relatedTarget;\n    dispatchEvent(element, showOffcanvasEvent);\n    if (showOffcanvasEvent.defaultPrevented) return;\n\n    // we elegantly hide any opened modal/offcanvas\n    const currentOpen = getCurrentOpen(element);\n    if (currentOpen && currentOpen !== element) {\n      const this1 = getOffcanvasInstance(currentOpen);\n      const that1 = this1\n        || /* istanbul ignore next */getInstance(currentOpen, 'Modal');\n      that1.hide();\n    }\n\n    if (options.backdrop) {\n      if (!container.contains(overlay)) {\n        appendOverlay(container, true);\n      } else {\n        toggleOverlayType();\n      }\n\n      overlayDelay = getElementTransitionDuration(overlay);\n      showOverlay();\n\n      setTimeout(() => beforeOffcanvasShow(self), overlayDelay);\n    } else {\n      beforeOffcanvasShow(self);\n      /* istanbul ignore else */\n      if (currentOpen && hasClass(overlay, showClass)) {\n        hideOverlay();\n      }\n    }\n  }\n\n  /**\n   * Hides the offcanvas from the user.\n   * @param {Function=} callback when `true` it will skip animation\n   */\n  hide(callback) {\n    const self = this;\n    const { element, relatedTarget } = self;\n\n    if (!hasClass(element, showClass)) return;\n\n    hideOffcanvasEvent.relatedTarget = relatedTarget;\n    hiddenOffcanvasEvent.relatedTarget = relatedTarget;\n    dispatchEvent(element, hideOffcanvasEvent);\n    if (hideOffcanvasEvent.defaultPrevented) return;\n\n    addClass(element, offcanvasTogglingClass);\n    removeClass(element, showClass);\n\n    if (!callback) {\n      emulateTransitionEnd(element, () => beforeOffcanvasHide(self, callback));\n    } else beforeOffcanvasHide(self, callback);\n  }\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const self = this;\n    toggleOffcanvasEvents(self);\n    self.hide(() => super.dispose());\n  }\n}\n\nObjectAssign(Offcanvas, {\n  selector: offcanvasSelector,\n  init: offcanvasInitCallback,\n  getInstance: getOffcanvasInstance,\n});\n\n/** @type {string} */\nconst popoverString = 'popover';\n\n/** @type {string} */\nconst popoverComponent = 'Popover';\n\n/** @type {string} */\nconst tooltipString = 'tooltip';\n\n/**\n * Returns a template for Popover / Tooltip.\n *\n * @param {string} tipType the expected markup type\n * @returns {string} the template markup\n */\nfunction getTipTemplate(tipType) {\n  const isTooltip = tipType === tooltipString;\n  const bodyClass = isTooltip ? `${tipType}-inner` : `${tipType}-body`;\n  const header = !isTooltip ? `<h3 class=\"${tipType}-header\"></h3>` : '';\n  const arrow = `<div class=\"${tipType}-arrow\"></div>`;\n  const body = `<div class=\"${bodyClass}\"></div>`;\n  return `<div class=\"${tipType}\" role=\"${tooltipString}\">${header + arrow + body}</div>`;\n}\n\n/**\n * Checks if an element is an `<svg>` (or any type of SVG element),\n * `<img>` or `<video>`.\n *\n * *Tooltip* / *Popover* works different with media elements.\n * @param {any} element the target element\n * @returns {boolean} the query result\n */\n\nconst isMedia = (element) => (\n  element\n  && element.nodeType === 1\n  && ['SVG', 'Image', 'Video'].some((s) => element.constructor.name.includes(s))) || false;\n\n/**\n * Returns an `{x,y}` object with the target\n * `HTMLElement` / `Node` scroll position.\n *\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement | Window} element target node / element\n * @returns {{x: number, y: number}} the scroll tuple\n */\nfunction getNodeScroll(element) {\n  const isWin = 'scrollX' in element;\n  const x = isWin ? element.scrollX : element.scrollLeft;\n  const y = isWin ? element.scrollY : element.scrollTop;\n\n  return { x, y };\n}\n\n/**\n * Checks if a target `HTMLElement` is affected by scale.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element target\n * @returns {boolean} the query result\n */\nfunction isScaledElement(element) {\n  if (!element || !isHTMLElement(element)) return false;\n  const { width, height } = getBoundingClientRect(element);\n  const { offsetWidth, offsetHeight } = element;\n  return Math.round(width) !== offsetWidth\n    || Math.round(height) !== offsetHeight;\n}\n\n/**\n * Returns the rect relative to an offset parent.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element target\n * @param {ParentNode | Window} offsetParent the container / offset parent\n * @param {{x: number, y: number}} scroll the offsetParent scroll position\n * @returns {SHORTY.OffsetRect}\n */\nfunction getRectRelativeToOffsetParent(element, offsetParent, scroll) {\n  const isParentAnElement = isHTMLElement(offsetParent);\n  const rect = getBoundingClientRect(element, isParentAnElement && isScaledElement(offsetParent));\n  const offsets = { x: 0, y: 0 };\n\n  /* istanbul ignore next */\n  if (isParentAnElement) {\n    const offsetRect = getBoundingClientRect(offsetParent, true);\n    offsets.x = offsetRect.x + offsetParent.clientLeft;\n    offsets.y = offsetRect.y + offsetParent.clientTop;\n  }\n\n  return {\n    x: rect.left + scroll.x - offsets.x,\n    y: rect.top + scroll.y - offsets.y,\n    width: rect.width,\n    height: rect.height,\n  };\n}\n\n/** @type {Record<string, string>} */\nconst tipClassPositions = {\n  top: 'top',\n  bottom: 'bottom',\n  left: 'start',\n  right: 'end',\n};\n\n/**\n * Style popovers and tooltips.\n * @param {BSN.Tooltip | BSN.Popover} self the `Popover` / `Tooltip` instance\n * @param {PointerEvent=} e event object\n */\nfunction styleTip(self, e) {\n  const tipClasses = /\\b(top|bottom|start|end)+/;\n  const {\n    element, tooltip, options, arrow, offsetParent,\n  } = self;\n  const tipPositions = { ...tipClassPositions };\n\n  const RTL = isRTL(element);\n  if (RTL) {\n    tipPositions.left = 'end';\n    tipPositions.right = 'start';\n  }\n\n  // reset tooltip style (top: 0, left: 0 works best)\n  setElementStyle(tooltip, {\n    // top: '0px', left: '0px', right: '', bottom: '',\n    top: '', left: '', right: '', bottom: '',\n  });\n  const isPopover = self.name === popoverComponent;\n  const {\n    offsetWidth: tipWidth, offsetHeight: tipHeight,\n  } = tooltip;\n  const {\n    clientWidth: htmlcw, clientHeight: htmlch,\n  } = getDocumentElement(element);\n  const { container } = options;\n  let { placement } = options;\n  const {\n    left: parentLeft, right: parentRight, top: parentTop,\n  } = getBoundingClientRect(container, true);\n  const {\n    clientWidth: parentCWidth, offsetWidth: parentOWidth,\n  } = container;\n  const scrollbarWidth = Math.abs(parentCWidth - parentOWidth);\n  // const tipAbsolute = getElementStyle(tooltip, 'position') === 'absolute';\n  const parentPosition = getElementStyle(container, 'position');\n  // const absoluteParent = parentPosition === 'absolute';\n  const fixedParent = parentPosition === 'fixed';\n  const staticParent = parentPosition === 'static';\n  const stickyParent = parentPosition === 'sticky';\n  const isSticky = stickyParent && parentTop === parseFloat(getElementStyle(container, 'top'));\n  // const absoluteTarget = getElementStyle(element, 'position') === 'absolute';\n  // const stickyFixedParent = ['sticky', 'fixed'].includes(parentPosition);\n  const leftBoundry = RTL && fixedParent ? scrollbarWidth : 0;\n  const rightBoundry = fixedParent ? parentCWidth + parentLeft + (RTL ? scrollbarWidth : 0)\n    : parentCWidth + parentLeft + (htmlcw - parentRight) - 1;\n  const {\n    width: elemWidth,\n    height: elemHeight,\n    left: elemRectLeft,\n    right: elemRectRight,\n    top: elemRectTop,\n  } = getBoundingClientRect(element, true);\n\n  const scroll = getNodeScroll(offsetParent);\n  const { x, y } = getRectRelativeToOffsetParent(element, offsetParent, scroll);\n  // reset arrow style\n  setElementStyle(arrow, {\n    top: '', left: '', right: '', bottom: '',\n  });\n  let topPosition;\n  let leftPosition;\n  let rightPosition;\n  let arrowTop;\n  let arrowLeft;\n  let arrowRight;\n\n  const arrowWidth = arrow.offsetWidth || 0;\n  const arrowHeight = arrow.offsetHeight || 0;\n  const arrowAdjust = arrowWidth / 2;\n\n  // check placement\n  let topExceed = elemRectTop - tipHeight - arrowHeight < 0;\n  let bottomExceed = elemRectTop + tipHeight + elemHeight\n    + arrowHeight >= htmlch;\n  let leftExceed = elemRectLeft - tipWidth - arrowWidth < leftBoundry;\n  let rightExceed = elemRectLeft + tipWidth + elemWidth\n    + arrowWidth >= rightBoundry;\n\n  const horizontal = ['left', 'right'];\n  const vertical = ['top', 'bottom'];\n\n  topExceed = horizontal.includes(placement)\n    ? elemRectTop + elemHeight / 2 - tipHeight / 2 - arrowHeight < 0\n    : topExceed;\n  bottomExceed = horizontal.includes(placement)\n    ? elemRectTop + tipHeight / 2 + elemHeight / 2 + arrowHeight >= htmlch\n    : bottomExceed;\n  leftExceed = vertical.includes(placement)\n    ? elemRectLeft + elemWidth / 2 - tipWidth / 2 < leftBoundry\n    : leftExceed;\n  rightExceed = vertical.includes(placement)\n    ? elemRectLeft + tipWidth / 2 + elemWidth / 2 >= rightBoundry\n    : rightExceed;\n\n  // first remove side positions if both left and right limits are exceeded\n  // we usually fall back to top|bottom\n  placement = (horizontal.includes(placement)) && leftExceed && rightExceed ? 'top' : placement;\n  // second, recompute placement\n  placement = placement === 'top' && topExceed ? 'bottom' : placement;\n  placement = placement === 'bottom' && bottomExceed ? 'top' : placement;\n  placement = placement === 'left' && leftExceed ? 'right' : placement;\n  placement = placement === 'right' && rightExceed ? 'left' : placement;\n\n  // update tooltip/popover class\n  if (!tooltip.className.includes(placement)) {\n    tooltip.className = tooltip.className.replace(tipClasses, tipPositions[placement]);\n  }\n\n  // compute tooltip / popover coordinates\n  /* istanbul ignore else */\n  if (horizontal.includes(placement)) { // secondary|side positions\n    if (placement === 'left') { // LEFT\n      leftPosition = x - tipWidth - (isPopover ? arrowWidth : 0);\n    } else { // RIGHT\n      leftPosition = x + elemWidth + (isPopover ? arrowWidth : 0);\n    }\n\n    // adjust top and arrow\n    if (topExceed) {\n      topPosition = y;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = elemHeight / 2 - arrowWidth;\n    } else if (bottomExceed) {\n      topPosition = y - tipHeight + elemHeight;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = tipHeight - elemHeight / 2 - arrowWidth;\n    } else {\n      topPosition = y - tipHeight / 2 + elemHeight / 2;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = tipHeight / 2 - arrowHeight / 2;\n    }\n  } else if (vertical.includes(placement)) {\n    if (e && isMedia(element)) {\n      let eX = 0;\n      let eY = 0;\n      if (staticParent) {\n        eX = e.pageX;\n        eY = e.pageY;\n      } else { // fixedParent | stickyParent\n        eX = e.clientX - parentLeft + (fixedParent ? scroll.x : 0);\n        eY = e.clientY - parentTop + (fixedParent ? scroll.y : 0);\n      }\n\n      // some weird RTL bug\n      eX -= RTL && fixedParent && scrollbarWidth ? scrollbarWidth : 0;\n\n      if (placement === 'top') {\n        topPosition = eY - tipHeight - arrowWidth;\n      } else {\n        topPosition = eY + arrowWidth;\n      }\n\n      // adjust (left | right) and also the arrow\n      if (e.clientX - tipWidth / 2 < leftBoundry) {\n        leftPosition = 0;\n        arrowLeft = eX - arrowAdjust;\n      } else if (e.clientX + tipWidth / 2 > rightBoundry) {\n        leftPosition = 'auto';\n        rightPosition = 0;\n        arrowRight = rightBoundry - eX - arrowAdjust;\n        arrowRight -= fixedParent ? parentLeft + (RTL ? scrollbarWidth : 0) : 0;\n\n      // normal top/bottom\n      } else {\n        leftPosition = eX - tipWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    } else {\n      if (placement === 'top') {\n        topPosition = y - tipHeight - (isPopover ? arrowHeight : 0);\n      } else { // BOTTOM\n        topPosition = y + elemHeight + (isPopover ? arrowHeight : 0);\n      }\n\n      // adjust left | right and also the arrow\n      if (leftExceed) {\n        leftPosition = 0;\n        arrowLeft = x + elemWidth / 2 - arrowAdjust;\n      } else if (rightExceed) {\n        leftPosition = 'auto';\n        rightPosition = 0;\n        arrowRight = elemWidth / 2 + rightBoundry - elemRectRight - arrowAdjust;\n      } else {\n        leftPosition = x - tipWidth / 2 + elemWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    }\n  }\n\n  // apply style to tooltip/popover\n  setElementStyle(tooltip, {\n    top: `${topPosition}px`,\n    left: leftPosition === 'auto' ? leftPosition : `${leftPosition}px`,\n    right: rightPosition !== undefined ? `${rightPosition}px` : '',\n  });\n\n  // update arrow placement\n  /* istanbul ignore else */\n  if (isHTMLElement(arrow)) {\n    if (arrowTop !== undefined) {\n      arrow.style.top = `${arrowTop}px`;\n    }\n    if (arrowLeft !== undefined) {\n      arrow.style.left = `${arrowLeft}px`;\n    } else if (arrowRight !== undefined) {\n      arrow.style.right = `${arrowRight}px`;\n    }\n  }\n}\n\nconst tooltipDefaults = {\n  /** @type {string} */\n  template: getTipTemplate(tooltipString),\n  /** @type {string?} */\n  title: null, // string\n  /** @type {string?} */\n  customClass: null, // string | null\n  /** @type {string} */\n  trigger: 'hover focus',\n  /** @type {string?} */\n  placement: 'top', // string\n  /** @type {((c:string)=>string)?} */\n  sanitizeFn: null, // function\n  /** @type {boolean} */\n  animation: true, // bool\n  /** @type {number} */\n  delay: 200, // number\n  /** @type {HTMLElement?} */\n  container: null,\n};\n\n/**\n * A global namespace for aria-describedby.\n * @type {string}\n */\nconst ariaDescribedBy = 'aria-describedby';\n\n/**\n * A global namespace for `mousedown` event.\n * @type {string}\n */\nconst mousedownEvent = 'mousedown';\n\n/**\n * A global namespace for `mousemove` event.\n * @type {string}\n */\nconst mousemoveEvent = 'mousemove';\n\n/**\n * A global namespace for `focusin` event.\n * @type {string}\n */\nconst focusinEvent = 'focusin';\n\n/**\n * A global namespace for `focusout` event.\n * @type {string}\n */\nconst focusoutEvent = 'focusout';\n\n/**\n * A global namespace for `hover` event.\n * @type {string}\n */\nconst mousehoverEvent = 'hover';\n\n/**\n * A global namespace for `touchstart` event.\n * @type {string}\n */\nconst touchstartEvent = 'touchstart';\n\nlet elementUID = 0;\nlet elementMapUID = 0;\nconst elementIDMap = new Map();\n\n/**\n * Returns a unique identifier for popover, tooltip, scrollspy.\n *\n * @param {HTMLElement} element target element\n * @param {string=} key predefined key\n * @returns {number} an existing or new unique ID\n */\nfunction getUID(element, key) {\n  let result = key ? elementUID : elementMapUID;\n\n  if (key) {\n    const elID = getUID(element);\n    const elMap = elementIDMap.get(elID) || new Map();\n    if (!elementIDMap.has(elID)) {\n      elementIDMap.set(elID, elMap);\n    }\n    if (!elMap.has(key)) {\n      elMap.set(key, result);\n      elementUID += 1;\n    } else result = elMap.get(key);\n  } else {\n    const elkey = element.id || element;\n\n    if (!elementIDMap.has(elkey)) {\n      elementIDMap.set(elkey, result);\n      elementMapUID += 1;\n    } else result = elementIDMap.get(elkey);\n  }\n  return result;\n}\n\n/**\n * Checks if an object is a `Function`.\n *\n * @param {any} fn the target object\n * @returns {boolean} the query result\n */\nconst isFunction = (fn) => (fn && fn.constructor.name === 'Function') || false;\n\nconst { userAgentData: uaDATA } = navigator;\n\n/**\n * A global namespace for `userAgentData` object.\n */\nconst userAgentData = uaDATA;\n\nconst { userAgent: userAgentString } = navigator;\n\n/**\n * A global namespace for `navigator.userAgent` string.\n */\nconst userAgent = userAgentString;\n\nconst appleBrands = /(iPhone|iPod|iPad)/;\n\n/**\n * A global `boolean` for Apple browsers.\n * @type {boolean}\n */\nconst isApple = userAgentData ? userAgentData.brands.some((x) => appleBrands.test(x.brand))\n  : /* istanbul ignore next */appleBrands.test(userAgent);\n\n/**\n * Global namespace for `data-bs-title` attribute.\n */\nconst dataOriginalTitle = 'data-original-title';\n\n/** @type {string} */\nconst tooltipComponent = 'Tooltip';\n\n/**\n * Checks if an object is a `NodeList`.\n * => equivalent to `object instanceof NodeList`\n *\n * @param {any} object the target object\n * @returns {boolean} the query result\n */\nconst isNodeList = (object) => (object && object.constructor.name === 'NodeList') || false;\n\n/**\n * Shortcut for `typeof SOMETHING === \"string\"`.\n *\n * @param  {any} str input value\n * @returns {boolean} the query result\n */\nconst isString = (str) => typeof str === 'string';\n\n/**\n * Shortcut for `Array.isArray()` static method.\n *\n * @param  {any} arr array-like iterable object\n * @returns {boolean} the query result\n */\nconst isArray = (arr) => Array.isArray(arr);\n\n/**\n * Append an existing `Element` to Popover / Tooltip component or HTML\n * markup string to be parsed & sanitized to be used as popover / tooltip content.\n *\n * @param {HTMLElement} element target\n * @param {Node | string} content the `Element` to append / string\n * @param {ReturnType<any>} sanitizeFn a function to sanitize string content\n */\nfunction setHtml(element, content, sanitizeFn) {\n  /* istanbul ignore next */\n  if (!isHTMLElement(element) || (isString(content) && !content.length)) return;\n\n  /* istanbul ignore else */\n  if (isString(content)) {\n    let dirty = content.trim(); // fixing #233\n    if (isFunction(sanitizeFn)) dirty = sanitizeFn(dirty);\n\n    const win = getWindow(element);\n    const domParser = new win.DOMParser();\n    const tempDocument = domParser.parseFromString(dirty, 'text/html');\n    element.append(...[...tempDocument.body.childNodes]);\n  } else if (isHTMLElement(content)) {\n    element.append(content);\n  } else if (isNodeList(content)\n    || (isArray(content) && content.every(isNode))) {\n    element.append(...[...content]);\n  }\n}\n\n/**\n * Creates a new tooltip / popover.\n *\n * @param {BSN.Popover | BSN.Tooltip} self the `Tooltip` / `Popover` instance\n */\nfunction createTip(self) {\n  const { id, element, options } = self;\n  const {\n    animation, customClass, sanitizeFn, placement, dismissible,\n    title, content, template, btnClose,\n  } = options;\n  const isTooltip = self.name === tooltipComponent;\n  const tipString = isTooltip ? tooltipString : popoverString;\n  const tipPositions = { ...tipClassPositions };\n  let titleParts = [];\n  let contentParts = [];\n\n  if (isRTL(element)) {\n    tipPositions.left = 'end';\n    tipPositions.right = 'start';\n  }\n\n  // set initial popover class\n  const placementClass = `bs-${tipString}-${tipPositions[placement]}`;\n\n  // load template\n  /** @type {HTMLElement?} */\n  let tooltipTemplate;\n  if (isHTMLElement(template)) {\n    tooltipTemplate = template;\n  } else {\n    const htmlMarkup = createElement('div');\n    setHtml(htmlMarkup, template, sanitizeFn);\n    tooltipTemplate = htmlMarkup.firstChild;\n  }\n\n  // set popover markup\n  self.tooltip = isHTMLElement(tooltipTemplate) && tooltipTemplate.cloneNode(true);\n\n  const { tooltip } = self;\n\n  // set id and role attributes\n  setAttribute(tooltip, 'id', id);\n  setAttribute(tooltip, 'role', tooltipString);\n\n  const bodyClass = isTooltip ? `${tooltipString}-inner` : `${popoverString}-body`;\n  const tooltipHeader = isTooltip ? null : querySelector(`.${popoverString}-header`, tooltip);\n  const tooltipBody = querySelector(`.${bodyClass}`, tooltip);\n\n  // set arrow and enable access for styleTip\n  self.arrow = querySelector(`.${tipString}-arrow`, tooltip);\n  const { arrow } = self;\n\n  if (isHTMLElement(title)) titleParts = [title.cloneNode(true)];\n  else {\n    const tempTitle = createElement('div');\n    setHtml(tempTitle, title, sanitizeFn);\n    titleParts = [...[...tempTitle.childNodes]];\n  }\n\n  if (isHTMLElement(content)) contentParts = [content.cloneNode(true)];\n  else {\n    const tempContent = createElement('div');\n    setHtml(tempContent, content, sanitizeFn);\n    contentParts = [...[...tempContent.childNodes]];\n  }\n\n  // set dismissible button\n  if (dismissible) {\n    if (title) {\n      if (isHTMLElement(btnClose)) titleParts = [...titleParts, btnClose.cloneNode(true)];\n      else {\n        const tempBtn = createElement('div');\n        setHtml(tempBtn, btnClose, sanitizeFn);\n        titleParts = [...titleParts, tempBtn.firstChild];\n      }\n    } else {\n      /* istanbul ignore else */\n      if (tooltipHeader) tooltipHeader.remove();\n      if (isHTMLElement(btnClose)) contentParts = [...contentParts, btnClose.cloneNode(true)];\n      else {\n        const tempBtn = createElement('div');\n        setHtml(tempBtn, btnClose, sanitizeFn);\n        contentParts = [...contentParts, tempBtn.firstChild];\n      }\n    }\n  }\n\n  // fill the template with content from options / data attributes\n  // also sanitize title && content\n  /* istanbul ignore else */\n  if (!isTooltip) {\n    /* istanbul ignore else */\n    if (title && tooltipHeader) setHtml(tooltipHeader, titleParts, sanitizeFn);\n    /* istanbul ignore else */\n    if (content && tooltipBody) setHtml(tooltipBody, contentParts, sanitizeFn);\n    // set btn\n    self.btn = querySelector('.btn-close', tooltip);\n  } else if (title && tooltipBody) setHtml(tooltipBody, title, sanitizeFn);\n\n  // Bootstrap 5.2.x\n  addClass(tooltip, 'position-absolute');\n  addClass(arrow, 'position-absolute');\n\n  // set popover animation and placement\n  /* istanbul ignore else */\n  if (!hasClass(tooltip, tipString)) addClass(tooltip, tipString);\n  /* istanbul ignore else */\n  if (animation && !hasClass(tooltip, fadeClass)) addClass(tooltip, fadeClass);\n  /* istanbul ignore else */\n  if (customClass && !hasClass(tooltip, customClass)) {\n    addClass(tooltip, customClass);\n  }\n  /* istanbul ignore else */\n  if (!hasClass(tooltip, placementClass)) addClass(tooltip, placementClass);\n}\n\n/**\n * @param {HTMLElement} tip target\n * @param {ParentNode} container parent container\n * @returns {boolean}\n */\nfunction isVisibleTip(tip, container) {\n  return isHTMLElement(tip) && container.contains(tip);\n}\n\n/* Native JavaScript for Bootstrap 5 | Tooltip\n---------------------------------------------- */\n\n// TOOLTIP PRIVATE GC\n// ==================\nconst tooltipSelector = `[${dataBsToggle}=\"${tooltipString}\"],[data-tip=\"${tooltipString}\"]`;\nconst titleAttr = 'title';\n\n/**\n * Static method which returns an existing `Tooltip` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Tooltip>}\n */\nlet getTooltipInstance = (element) => getInstance(element, tooltipComponent);\n\n/**\n * A `Tooltip` initialization callback.\n * @type {BSN.InitCallback<Tooltip>}\n */\nconst tooltipInitCallback = (element) => new Tooltip(element);\n\n// TOOLTIP PRIVATE METHODS\n// =======================\n/**\n * Removes the tooltip from the DOM.\n *\n * @param {Tooltip} self the `Tooltip` instance\n */\nfunction removeTooltip(self) {\n  const { element, tooltip } = self;\n  removeAttribute(element, ariaDescribedBy);\n  tooltip.remove();\n}\n\n/**\n * Executes after the instance has been disposed.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {Function=} callback the parent dispose callback\n */\nfunction disposeTooltipComplete(self, callback) {\n  const { element } = self;\n  toggleTooltipHandlers(self);\n\n  /* istanbul ignore else */\n  if (hasAttribute(element, dataOriginalTitle) && self.name === tooltipComponent) {\n    toggleTooltipTitle(self);\n  }\n  /* istanbul ignore else */\n  if (callback) callback();\n}\n\n/**\n * Toggles on/off the special `Tooltip` event listeners.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipAction(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n\n  action(getDocument(element), touchstartEvent, self.handleTouch, passiveHandler);\n\n  /* istanbul ignore else */\n  if (!isMedia(element)) {\n    [scrollEvent, resizeEvent].forEach((ev) => {\n      action(getWindow(element), ev, self.update, passiveHandler);\n    });\n  }\n}\n\n/**\n * Executes after the tooltip was shown to the user.\n *\n * @param {Tooltip} self the `Tooltip` instance\n */\nfunction tooltipShownAction(self) {\n  const { element } = self;\n  const shownTooltipEvent = OriginalEvent(`shown.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self, true);\n  dispatchEvent(element, shownTooltipEvent);\n  Timer.clear(element, 'in');\n}\n\n/**\n * Executes after the tooltip was hidden to the user.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {Function=} callback the dispose callback\n */\nfunction tooltipHiddenAction(self, callback) {\n  const { element } = self;\n  const hiddenTooltipEvent = OriginalEvent(`hidden.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self);\n  removeTooltip(self);\n  dispatchEvent(element, hiddenTooltipEvent);\n  if (isFunction(callback)) callback();\n  Timer.clear(element, 'out');\n}\n\n/**\n * Toggles on/off the `Tooltip` event listeners.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  // btn is only for dismissible popover\n  const { element, options, btn } = self;\n  const { trigger, dismissible } = options;\n\n  if (trigger.includes('manual')) return;\n\n  self.enabled = !!add;\n\n  /** @type {string[]} */\n  const triggerOptions = trigger.split(' ');\n  const elemIsMedia = isMedia(element);\n\n  if (elemIsMedia) {\n    action(element, mousemoveEvent, self.update, passiveHandler);\n  }\n\n  triggerOptions.forEach((tr) => {\n    /* istanbul ignore else */\n    if (elemIsMedia || tr === mousehoverEvent) {\n      action(element, mousedownEvent, self.show);\n      action(element, mouseenterEvent, self.show);\n\n      /* istanbul ignore else */\n      if (dismissible && btn) {\n        action(btn, mouseclickEvent, self.hide);\n      } else {\n        action(element, mouseleaveEvent, self.hide);\n        action(getDocument(element), touchstartEvent, self.handleTouch, passiveHandler);\n      }\n    } else if (tr === mouseclickEvent) {\n      action(element, tr, (!dismissible ? self.toggle : self.show));\n    } else if (tr === focusEvent) {\n      action(element, focusinEvent, self.show);\n      /* istanbul ignore else */\n      if (!dismissible) action(element, focusoutEvent, self.hide);\n      /* istanbul ignore else */\n      if (isApple) {\n        action(element, mouseclickEvent, () => focus(element));\n      }\n    }\n  });\n}\n\n/**\n * Toggles on/off the `Tooltip` event listeners that hide/update the tooltip.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipOpenHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element, options, offsetParent } = self;\n  const { container } = options;\n  const { offsetHeight, scrollHeight } = container;\n  const parentModal = closest(element, `.${modalString}`);\n  const parentOffcanvas = closest(element, `.${offcanvasString}`);\n\n  /* istanbul ignore else */\n  if (!isMedia(element)) {\n    const win = getWindow(element);\n    const overflow = offsetHeight !== scrollHeight;\n    const scrollTarget = overflow || offsetParent !== win ? container : win;\n    action(win, resizeEvent, self.update, passiveHandler);\n    action(scrollTarget, scrollEvent, self.update, passiveHandler);\n  }\n\n  // dismiss tooltips inside modal / offcanvas\n  if (parentModal) action(parentModal, `hide.bs.${modalString}`, self.hide);\n  if (parentOffcanvas) action(parentOffcanvas, `hide.bs.${offcanvasString}`, self.hide);\n}\n\n/**\n * Toggles the `title` and `data-original-title` attributes.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {string=} content when `true`, event listeners are added\n */\nfunction toggleTooltipTitle(self, content) {\n  // [0 - add, 1 - remove] | [0 - remove, 1 - add]\n  const titleAtt = [dataOriginalTitle, titleAttr];\n  const { element } = self;\n\n  setAttribute(element, titleAtt[content ? 0 : 1],\n    (content || getAttribute(element, titleAtt[0])));\n  removeAttribute(element, titleAtt[content ? 1 : 0]);\n}\n\n// TOOLTIP DEFINITION\n// ==================\n/** Creates a new `Tooltip` instance. */\nclass Tooltip extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target element\n   * @param {BSN.Options.Tooltip=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n\n    // bind\n    const self = this;\n    const { element } = self;\n    const isTooltip = self.name === tooltipComponent;\n    const tipString = isTooltip ? tooltipString : popoverString;\n    const tipComponent = isTooltip ? tooltipComponent : popoverComponent;\n\n    /* istanbul ignore next: this is to set Popover too */\n    getTooltipInstance = (elem) => getInstance(elem, tipComponent);\n\n    // additional properties\n    /** @type {any} */\n    self.tooltip = {};\n    if (!isTooltip) {\n      /** @type {any?} */\n      self.btn = null;\n    }\n    /** @type {any} */\n    self.arrow = {};\n    /** @type {any} */\n    self.offsetParent = {};\n    /** @type {boolean} */\n    self.enabled = true;\n    /** @type {string} Set unique ID for `aria-describedby`. */\n    self.id = `${tipString}-${getUID(element, tipString)}`;\n\n    // instance options\n    const { options } = self;\n\n    // invalidate\n    if ((!options.title && isTooltip) || (!isTooltip && !options.content)) {\n      // throw Error(`${this.name} Error: target has no content set.`);\n      return;\n    }\n\n    const container = querySelector(options.container, getDocument(element));\n    const idealContainer = getElementContainer(element);\n\n    // bypass container option when its position is static/relative\n    self.options.container = !container || (container\n      && ['static', 'relative'].includes(getElementStyle(container, 'position')))\n      ? idealContainer\n      : /* istanbul ignore next */container || getDocumentBody(element);\n\n    // reset default options\n    tooltipDefaults[titleAttr] = null;\n\n    // all functions bind\n    self.handleTouch = self.handleTouch.bind(self);\n    self.update = self.update.bind(self);\n    self.show = self.show.bind(self);\n    self.hide = self.hide.bind(self);\n    self.toggle = self.toggle.bind(self);\n\n    // set title attributes and add event listeners\n    /* istanbul ignore else */\n    if (hasAttribute(element, titleAttr) && isTooltip) {\n      toggleTooltipTitle(self, options.title);\n    }\n\n    // create tooltip here\n    createTip(self);\n\n    // attach events\n    toggleTooltipHandlers(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return tooltipComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return tooltipDefaults; }\n  /* eslint-enable */\n\n  // TOOLTIP PUBLIC METHODS\n  // ======================\n  /**\n   * Shows the tooltip.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip}\n   */\n  show(e) {\n    const self = this;\n    const {\n      options, tooltip, element, id,\n    } = self;\n    const { container, animation } = options;\n    const outTimer = Timer.get(element, 'out');\n\n    Timer.clear(element, 'out');\n\n    if (tooltip && !outTimer && !isVisibleTip(tooltip, container)) {\n      Timer.set(element, () => {\n        const showTooltipEvent = OriginalEvent(`show.bs.${toLowerCase(self.name)}`);\n        dispatchEvent(element, showTooltipEvent);\n        if (showTooltipEvent.defaultPrevented) return;\n\n        // append to container\n        container.append(tooltip);\n        setAttribute(element, ariaDescribedBy, `#${id}`);\n        // set offsetParent\n        self.offsetParent = getElementContainer(tooltip, true);\n\n        self.update(e);\n        toggleTooltipOpenHandlers(self, true);\n\n        /* istanbul ignore else */\n        if (!hasClass(tooltip, showClass)) addClass(tooltip, showClass);\n        /* istanbul ignore else */\n        if (animation) emulateTransitionEnd(tooltip, () => tooltipShownAction(self));\n        else tooltipShownAction(self);\n      }, 17, 'in');\n    }\n  }\n\n  /**\n   * Hides the tooltip.\n   *\n   * @this {Tooltip} the Tooltip instance\n   * @param {Function=} callback the dispose callback\n   */\n  hide(callback) {\n    const self = this;\n    const { options, tooltip, element } = self;\n    const { container, animation, delay } = options;\n\n    Timer.clear(element, 'in');\n\n    /* istanbul ignore else */\n    if (tooltip && isVisibleTip(tooltip, container)) {\n      Timer.set(element, () => {\n        const hideTooltipEvent = OriginalEvent(`hide.bs.${toLowerCase(self.name)}`);\n        dispatchEvent(element, hideTooltipEvent);\n\n        if (hideTooltipEvent.defaultPrevented) return;\n\n        removeClass(tooltip, showClass);\n        toggleTooltipOpenHandlers(self);\n\n        /* istanbul ignore else */\n        if (animation) emulateTransitionEnd(tooltip, () => tooltipHiddenAction(self, callback));\n        else tooltipHiddenAction(self, callback);\n      }, delay + 17, 'out');\n    }\n  }\n\n  /**\n   * Updates the tooltip position.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip} the `Tooltip` instance\n   */\n  update(e) {\n    styleTip(this, e);\n  }\n\n  /**\n   * Toggles the tooltip visibility.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip} the instance\n   */\n  toggle(e) {\n    const self = this;\n    const { tooltip, options } = self;\n\n    if (!isVisibleTip(tooltip, options.container)) self.show(e);\n    else self.hide();\n  }\n\n  /** Enables the tooltip. */\n  enable() {\n    const self = this;\n    const { enabled } = self;\n    /* istanbul ignore else */\n    if (!enabled) {\n      toggleTooltipHandlers(self, true);\n      self.enabled = !enabled;\n    }\n  }\n\n  /** Disables the tooltip. */\n  disable() {\n    const self = this;\n    const {\n      tooltip, options, enabled,\n    } = self;\n    const { animation, container } = options;\n    /* istanbul ignore else */\n    if (enabled) {\n      if (isVisibleTip(tooltip, container) && animation) {\n        self.hide(() => toggleTooltipHandlers(self));\n      } else {\n        toggleTooltipHandlers(self);\n      }\n      self.enabled = !enabled;\n    }\n  }\n\n  /** Toggles the `disabled` property. */\n  toggleEnabled() {\n    const self = this;\n    if (!self.enabled) self.enable();\n    else self.disable();\n  }\n\n  /**\n   * Handles the `touchstart` event listener for `Tooltip`\n   * @this {Tooltip}\n   * @param {TouchEvent} e the `Event` object\n   */\n  handleTouch({ target }) {\n    const { tooltip, element } = this;\n\n    /* istanbul ignore next */\n    if (tooltip.contains(target) || target === element\n      || (target && element.contains(target))) ; else {\n      this.hide();\n    }\n  }\n\n  /** Removes the `Tooltip` from the target element. */\n  dispose() {\n    const self = this;\n    const { tooltip, options } = self;\n    const callback = () => disposeTooltipComplete(self, () => super.dispose());\n\n    if (options.animation && isVisibleTip(tooltip, options.container)) {\n      self.options.delay = 0; // reset delay\n      self.hide(callback);\n    } else {\n      callback();\n    }\n  }\n}\n\nObjectAssign(Tooltip, {\n  selector: tooltipSelector,\n  init: tooltipInitCallback,\n  getInstance: getTooltipInstance,\n  styleTip,\n});\n\n/* Native JavaScript for Bootstrap 5 | Popover\n---------------------------------------------- */\n\n// POPOVER PRIVATE GC\n// ==================\nconst popoverSelector = `[${dataBsToggle}=\"${popoverString}\"],[data-tip=\"${popoverString}\"]`;\n\nconst popoverDefaults = {\n  ...tooltipDefaults,\n  /** @type {string} */\n  template: getTipTemplate(popoverString),\n  /** @type {string} */\n  btnClose: '<button class=\"btn-close\" aria-label=\"Close\"></button>',\n  /** @type {boolean} */\n  dismissible: false,\n  /** @type {string?} */\n  content: null,\n};\n\n// POPOVER DEFINITION\n// ==================\n/** Returns a new `Popover` instance. */\nclass Popover extends Tooltip {\n  /* eslint-disable -- we want to specify Popover Options */\n  /**\n   * @param {HTMLElement | string} target the target element\n   * @param {BSN.Options.Popover=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n  }\n  /**\n   * Returns component name string.\n   */ \n  get name() { return popoverComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return popoverDefaults; }\n  /* eslint-enable */\n\n  /* extend original `show()` */\n  show() {\n    super.show();\n    // btn only exists within dismissible popover\n    const { options, btn } = this;\n    /* istanbul ignore else */\n    if (options.dismissible && btn) setTimeout(() => focus(btn), 17);\n  }\n}\n\n/**\n * Static method which returns an existing `Popover` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Popover>}\n */\nconst getPopoverInstance = (element) => getInstance(element, popoverComponent);\n\n/**\n * A `Popover` initialization callback.\n * @type {BSN.InitCallback<Popover>}\n */\nconst popoverInitCallback = (element) => new Popover(element);\n\nObjectAssign(Popover, {\n  selector: popoverSelector,\n  init: popoverInitCallback,\n  getInstance: getPopoverInstance,\n  styleTip,\n});\n\n/**\n * Shortcut for `HTMLElement.getElementsByTagName` method. Some `Node` elements\n * like `ShadowRoot` do not support `getElementsByTagName`.\n *\n * @param {string} selector the tag name\n * @param {ParentNode=} parent optional Element to look into\n * @return {HTMLCollectionOf<HTMLElement>} the 'HTMLCollection'\n */\nfunction getElementsByTagName(selector, parent) {\n  const lookUp = isNode(parent) ? parent : getDocument();\n  return lookUp.getElementsByTagName(selector);\n}\n\n/** @type {string} */\nconst scrollspyString = 'scrollspy';\n\n/** @type {string} */\nconst scrollspyComponent = 'ScrollSpy';\n\n/* Native JavaScript for Bootstrap 5 | ScrollSpy\n------------------------------------------------ */\n\n// SCROLLSPY PRIVATE GC\n// ====================\nconst scrollspySelector = '[data-bs-spy=\"scroll\"]';\n\nconst scrollspyDefaults = {\n  offset: 10,\n  target: null,\n};\n\n/**\n * Static method which returns an existing `ScrollSpy` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<ScrollSpy>}\n */\nconst getScrollSpyInstance = (element) => getInstance(element, scrollspyComponent);\n\n/**\n * A `ScrollSpy` initialization callback.\n * @type {BSN.InitCallback<ScrollSpy>}\n */\nconst scrollspyInitCallback = (element) => new ScrollSpy(element);\n\n// SCROLLSPY CUSTOM EVENT\n// ======================\nconst activateScrollSpy = OriginalEvent(`activate.bs.${scrollspyString}`);\n\n// SCROLLSPY PRIVATE METHODS\n// =========================\n/**\n * Update the state of all items.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n */\nfunction updateSpyTargets(self) {\n  const {\n    target, scrollTarget, options, itemsLength, scrollHeight, element,\n  } = self;\n  const { offset } = options;\n  const isWin = isWindow(scrollTarget);\n\n  const links = target && getElementsByTagName('A', target);\n  const scrollHEIGHT = scrollTarget && getScrollHeight(scrollTarget);\n\n  self.scrollTop = isWin ? scrollTarget.scrollY : scrollTarget.scrollTop;\n\n  // only update items/offsets once or with each mutation\n  /* istanbul ignore else */\n  if (links && (itemsLength !== links.length || scrollHEIGHT !== scrollHeight)) {\n    let href;\n    let targetItem;\n    let rect;\n\n    // reset arrays & update\n    self.items = [];\n    self.offsets = [];\n    self.scrollHeight = scrollHEIGHT;\n    self.maxScroll = self.scrollHeight - getOffsetHeight(self);\n\n    [...links].forEach((link) => {\n      href = getAttribute(link, 'href');\n      targetItem = href && href.charAt(0) === '#' && href.slice(-1) !== '#'\n        && querySelector(href, getDocument(element));\n\n      if (targetItem) {\n        self.items.push(link);\n        rect = getBoundingClientRect(targetItem);\n        self.offsets.push((isWin ? rect.top + self.scrollTop : targetItem.offsetTop) - offset);\n      }\n    });\n    self.itemsLength = self.items.length;\n  }\n}\n\n/**\n * Returns the `scrollHeight` property of the scrolling element.\n * @param {Node | Window} scrollTarget the `ScrollSpy` instance\n * @return {number} `scrollTarget` height\n */\nfunction getScrollHeight(scrollTarget) {\n  return isHTMLElement(scrollTarget)\n    ? scrollTarget.scrollHeight\n    : getDocumentElement(scrollTarget).scrollHeight;\n}\n\n/**\n * Returns the height property of the scrolling element.\n * @param {ScrollSpy} params the `ScrollSpy` instance\n * @returns {number}\n */\nfunction getOffsetHeight({ element, scrollTarget }) {\n  return (isWindow(scrollTarget))\n    ? scrollTarget.innerHeight\n    : getBoundingClientRect(element).height;\n}\n\n/**\n * Clear all items of the target.\n * @param {HTMLElement} target a single item\n */\nfunction clear(target) {\n  [...getElementsByTagName('A', target)].forEach((item) => {\n    if (hasClass(item, activeClass)) removeClass(item, activeClass);\n  });\n}\n\n/**\n * Activates a new item.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n * @param {HTMLElement} item a single item\n */\nfunction activate(self, item) {\n  const { target, element } = self;\n  clear(target);\n  self.activeItem = item;\n  addClass(item, activeClass);\n\n  // activate all parents\n  const parents = [];\n  let parentItem = item;\n  while (parentItem !== getDocumentBody(element)) {\n    parentItem = parentItem.parentElement;\n    if (hasClass(parentItem, 'nav') || hasClass(parentItem, 'dropdown-menu')) parents.push(parentItem);\n  }\n\n  parents.forEach((menuItem) => {\n    /** @type {HTMLElement?} */\n    const parentLink = menuItem.previousElementSibling;\n\n    /* istanbul ignore else */\n    if (parentLink && !hasClass(parentLink, activeClass)) {\n      addClass(parentLink, activeClass);\n    }\n  });\n\n  // dispatch\n  activateScrollSpy.relatedTarget = item;\n  dispatchEvent(element, activateScrollSpy);\n}\n\n/**\n * Toggles on/off the component event listener.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n * @param {boolean=} add when `true`, listener is added\n */\nfunction toggleSpyHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.scrollTarget, scrollEvent, self.refresh, passiveHandler);\n}\n\n// SCROLLSPY DEFINITION\n// ====================\n/** Returns a new `ScrollSpy` instance. */\nclass ScrollSpy extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target element\n   * @param {BSN.Options.ScrollSpy=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element & options\n    const { element, options } = self;\n\n    // additional properties\n    /** @type {HTMLElement?} */\n    self.target = querySelector(options.target, getDocument(element));\n\n    // invalidate\n    if (!self.target) return;\n\n    // set initial state\n    /** @type {HTMLElement | Window} */\n    self.scrollTarget = element.clientHeight < element.scrollHeight\n      ? element : getWindow(element);\n    /** @type {number} */\n    self.scrollTop = 0;\n    /** @type {number} */\n    self.maxScroll = 0;\n    /** @type {number} */\n    self.scrollHeight = 0;\n    /** @type {HTMLElement?} */\n    self.activeItem = null;\n    /** @type {HTMLElement[]} */\n    self.items = [];\n    /** @type {number} */\n    self.itemsLength = 0;\n    /** @type {number[]} */\n    self.offsets = [];\n\n    // bind events\n    self.refresh = self.refresh.bind(self);\n\n    // add event handlers\n    toggleSpyHandlers(self, true);\n\n    self.refresh();\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return scrollspyComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return scrollspyDefaults; }\n  /* eslint-enable */\n\n  // SCROLLSPY PUBLIC METHODS\n  // ========================\n  /** Updates all items. */\n  refresh() {\n    const self = this;\n    const { target } = self;\n\n    // check if target is visible and invalidate\n    /* istanbul ignore next */\n    if (target.offsetHeight === 0) return;\n\n    updateSpyTargets(self);\n\n    const {\n      scrollTop, maxScroll, itemsLength, items, activeItem,\n    } = self;\n\n    if (scrollTop >= maxScroll) {\n      const newActiveItem = items[itemsLength - 1];\n\n      /* istanbul ignore else */\n      if (activeItem !== newActiveItem) {\n        activate(self, newActiveItem);\n      }\n      return;\n    }\n\n    const { offsets } = self;\n\n    if (activeItem && scrollTop < offsets[0] && offsets[0] > 0) {\n      self.activeItem = null;\n      clear(target);\n      return;\n    }\n\n    items.forEach((item, i) => {\n      if (activeItem !== item && scrollTop >= offsets[i]\n        && (typeof offsets[i + 1] === 'undefined' || scrollTop < offsets[i + 1])) {\n        activate(self, item);\n      }\n    });\n  }\n\n  /** Removes `ScrollSpy` from the target element. */\n  dispose() {\n    toggleSpyHandlers(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(ScrollSpy, {\n  selector: scrollspySelector,\n  init: scrollspyInitCallback,\n  getInstance: getScrollSpyInstance,\n});\n\n/**\n * A global namespace for aria-selected.\n * @type {string}\n */\nconst ariaSelected = 'aria-selected';\n\n/** @type {string} */\nconst tabString = 'tab';\n\n/** @type {string} */\nconst tabComponent = 'Tab';\n\n/* Native JavaScript for Bootstrap 5 | Tab\n------------------------------------------ */\n\n// TAB PRIVATE GC\n// ================\nconst tabSelector = `[${dataBsToggle}=\"${tabString}\"]`;\n\n/**\n * Static method which returns an existing `Tab` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Tab>}\n */\nconst getTabInstance = (element) => getInstance(element, tabComponent);\n\n/**\n * A `Tab` initialization callback.\n * @type {BSN.InitCallback<Tab>}\n */\nconst tabInitCallback = (element) => new Tab(element);\n\n// TAB CUSTOM EVENTS\n// =================\nconst showTabEvent = OriginalEvent(`show.bs.${tabString}`);\nconst shownTabEvent = OriginalEvent(`shown.bs.${tabString}`);\nconst hideTabEvent = OriginalEvent(`hide.bs.${tabString}`);\nconst hiddenTabEvent = OriginalEvent(`hidden.bs.${tabString}`);\n\n/**\n * Stores the current active tab and its content\n * for a given `.nav` element.\n * @type {Map<HTMLElement, any>}\n */\nconst tabPrivate = new Map();\n\n// TAB PRIVATE METHODS\n// ===================\n/**\n * Executes after tab transition has finished.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabEnd(self) {\n  const { tabContent, nav } = self;\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(tabContent, collapsingClass)) {\n    tabContent.style.height = '';\n    removeClass(tabContent, collapsingClass);\n  }\n\n  /* istanbul ignore else */\n  if (nav) Timer.clear(nav);\n}\n\n/**\n * Executes before showing the tab content.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabShow(self) {\n  const {\n    element, tabContent, content: nextContent, nav,\n  } = self;\n  const { tab } = nav && tabPrivate.get(nav);\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(nextContent, fadeClass)) {\n    const { currentHeight, nextHeight } = tabPrivate.get(element);\n    if (currentHeight === nextHeight) {\n      triggerTabEnd(self);\n    } else {\n      // enables height animation\n      setTimeout(() => {\n        tabContent.style.height = `${nextHeight}px`;\n        reflow(tabContent);\n        emulateTransitionEnd(tabContent, () => triggerTabEnd(self));\n      }, 50);\n    }\n  } else if (nav) Timer.clear(nav);\n\n  shownTabEvent.relatedTarget = tab;\n  dispatchEvent(element, shownTabEvent);\n}\n\n/**\n * Executes before hiding the tab.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabHide(self) {\n  const {\n    element, content: nextContent, tabContent, nav,\n  } = self;\n  const { tab, content } = nav && tabPrivate.get(nav);\n  let currentHeight = 0;\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(nextContent, fadeClass)) {\n    [content, nextContent].forEach((c) => {\n      addClass(c, 'overflow-hidden');\n    });\n    currentHeight = content.scrollHeight || /* istanbul ignore next */0;\n  }\n\n  // update relatedTarget and dispatch event\n  showTabEvent.relatedTarget = tab;\n  hiddenTabEvent.relatedTarget = element;\n  dispatchEvent(element, showTabEvent);\n  if (showTabEvent.defaultPrevented) return;\n\n  addClass(nextContent, activeClass);\n  removeClass(content, activeClass);\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(nextContent, fadeClass)) {\n    const nextHeight = nextContent.scrollHeight;\n    tabPrivate.set(element, { currentHeight, nextHeight });\n\n    addClass(tabContent, collapsingClass);\n    tabContent.style.height = `${currentHeight}px`;\n    reflow(tabContent);\n    [content, nextContent].forEach((c) => {\n      removeClass(c, 'overflow-hidden');\n    });\n  }\n\n  if (nextContent && hasClass(nextContent, fadeClass)) {\n    setTimeout(() => {\n      addClass(nextContent, showClass);\n      emulateTransitionEnd(nextContent, () => {\n        triggerTabShow(self);\n      });\n    }, 1);\n  } else {\n    addClass(nextContent, showClass);\n    triggerTabShow(self);\n  }\n\n  dispatchEvent(tab, hiddenTabEvent);\n}\n\n/**\n * Returns the current active tab and its target content.\n * @param {Tab} self the `Tab` instance\n * @returns {Record<string, any>} the query result\n */\nfunction getActiveTab(self) {\n  const { nav } = self;\n\n  const activeTabs = getElementsByClassName(activeClass, nav);\n  /** @type {(HTMLElement)=} */\n  let tab;\n  /* istanbul ignore else */\n  if (activeTabs.length === 1\n    && !dropdownMenuClasses.some((c) => hasClass(activeTabs[0].parentElement, c))) {\n    [tab] = activeTabs;\n  } else if (activeTabs.length > 1) {\n    tab = activeTabs[activeTabs.length - 1];\n  }\n  const content = tab ? getTargetElement(tab) : null;\n  return { tab, content };\n}\n\n/**\n * Returns a parent dropdown.\n * @param {HTMLElement} element the `Tab` element\n * @returns {HTMLElement?} the parent dropdown\n */\nfunction getParentDropdown(element) {\n  const dropdown = closest(element, `.${dropdownMenuClasses.join(',.')}`);\n  return dropdown ? querySelector(`.${dropdownMenuClasses[0]}-toggle`, dropdown) : null;\n}\n\n/**\n * Toggles on/off the `click` event listener.\n * @param {Tab} self the `Tab` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleTabHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, tabClickHandler);\n}\n\n// TAB EVENT HANDLER\n// =================\n/**\n * Handles the `click` event listener.\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction tabClickHandler(e) {\n  const self = getTabInstance(this);\n  /* istanbul ignore next: must filter */\n  if (!self) return;\n  e.preventDefault();\n\n  self.show();\n}\n\n// TAB DEFINITION\n// ==============\n/** Creates a new `Tab` instance. */\nclass Tab extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target element\n   */\n  constructor(target) {\n    super(target);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n    const content = getTargetElement(element);\n\n    // no point initializing a tab without a corresponding content\n    if (!content) return;\n\n    const nav = closest(element, '.nav');\n    const container = closest(content, '.tab-content');\n\n    /** @type {HTMLElement?} */\n    self.nav = nav;\n    /** @type {HTMLElement} */\n    self.content = content;\n    /** @type {HTMLElement?} */\n    self.tabContent = container;\n\n    // event targets\n    /** @type {HTMLElement?} */\n    self.dropdown = getParentDropdown(element);\n\n    // show first Tab instance of none is shown\n    // suggested on #432\n    const { tab } = getActiveTab(self);\n    if (nav && !tab) {\n      const firstTab = querySelector(tabSelector, nav);\n      const firstTabContent = firstTab && getTargetElement(firstTab);\n\n      /* istanbul ignore else */\n      if (firstTabContent) {\n        addClass(firstTab, activeClass);\n        addClass(firstTabContent, showClass);\n        addClass(firstTabContent, activeClass);\n        setAttribute(element, ariaSelected, 'true');\n      }\n    }\n\n    // add event listener\n    toggleTabHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */  \n  get name() { return tabComponent; }\n  /* eslint-enable */\n\n  // TAB PUBLIC METHODS\n  // ==================\n  /** Shows the tab to the user. */\n  show() {\n    const self = this;\n    const {\n      element, content: nextContent, nav, dropdown,\n    } = self;\n\n    /* istanbul ignore else */\n    if (!(nav && Timer.get(nav)) && !hasClass(element, activeClass)) {\n      const { tab, content } = getActiveTab(self);\n\n      /* istanbul ignore else */\n      if (nav) tabPrivate.set(nav, { tab, content });\n\n      // update relatedTarget and dispatch\n      hideTabEvent.relatedTarget = element;\n\n      dispatchEvent(tab, hideTabEvent);\n      if (hideTabEvent.defaultPrevented) return;\n\n      addClass(element, activeClass);\n      setAttribute(element, ariaSelected, 'true');\n\n      const activeDropdown = getParentDropdown(tab);\n      if (activeDropdown && hasClass(activeDropdown, activeClass)) {\n        removeClass(activeDropdown, activeClass);\n      }\n\n      /* istanbul ignore else */\n      if (nav) {\n        const toggleTab = () => {\n          removeClass(tab, activeClass);\n          setAttribute(tab, ariaSelected, 'false');\n          if (dropdown && !hasClass(dropdown, activeClass)) addClass(dropdown, activeClass);\n        };\n\n        if (hasClass(content, fadeClass) || hasClass(nextContent, fadeClass)) {\n          Timer.set(nav, toggleTab, 1);\n        } else toggleTab();\n      }\n\n      removeClass(content, showClass);\n      if (hasClass(content, fadeClass)) {\n        emulateTransitionEnd(content, () => triggerTabHide(self));\n      } else {\n        triggerTabHide(self);\n      }\n    }\n  }\n\n  /** Removes the `Tab` component from the target element. */\n  dispose() {\n    toggleTabHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Tab, {\n  selector: tabSelector,\n  init: tabInitCallback,\n  getInstance: getTabInstance,\n});\n\n/** @type {string} */\nconst toastString = 'toast';\n\n/** @type {string} */\nconst toastComponent = 'Toast';\n\n/* Native JavaScript for Bootstrap 5 | Toast\n-------------------------------------------- */\n\n// TOAST PRIVATE GC\n// ================\nconst toastSelector = `.${toastString}`;\nconst toastDismissSelector = `[${dataBsDismiss}=\"${toastString}\"]`;\nconst toastToggleSelector = `[${dataBsToggle}=\"${toastString}\"]`;\nconst showingClass = 'showing';\n/** @deprecated */\nconst hideClass = 'hide';\n\nconst toastDefaults = {\n  animation: true,\n  autohide: true,\n  delay: 5000,\n};\n\n/**\n * Static method which returns an existing `Toast` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Toast>}\n */\nconst getToastInstance = (element) => getInstance(element, toastComponent);\n\n/**\n * A `Toast` initialization callback.\n * @type {BSN.InitCallback<Toast>}\n */\nconst toastInitCallback = (element) => new Toast(element);\n\n// TOAST CUSTOM EVENTS\n// ===================\nconst showToastEvent = OriginalEvent(`show.bs.${toastString}`);\nconst shownToastEvent = OriginalEvent(`shown.bs.${toastString}`);\nconst hideToastEvent = OriginalEvent(`hide.bs.${toastString}`);\nconst hiddenToastEvent = OriginalEvent(`hidden.bs.${toastString}`);\n\n// TOAST PRIVATE METHODS\n// =====================\n/**\n * Executes after the toast is shown to the user.\n * @param {Toast} self the `Toast` instance\n */\nfunction showToastComplete(self) {\n  const { element, options } = self;\n  removeClass(element, showingClass);\n  Timer.clear(element, showingClass);\n\n  dispatchEvent(element, shownToastEvent);\n  /* istanbul ignore else */\n  if (options.autohide) {\n    Timer.set(element, () => self.hide(), options.delay, toastString);\n  }\n}\n\n/**\n * Executes after the toast is hidden to the user.\n * @param {Toast} self the `Toast` instance\n */\nfunction hideToastComplete(self) {\n  const { element } = self;\n  removeClass(element, showingClass);\n  removeClass(element, showClass);\n  addClass(element, hideClass); // B/C\n  Timer.clear(element, toastString);\n  dispatchEvent(element, hiddenToastEvent);\n}\n\n/**\n * Executes before hiding the toast.\n * @param {Toast} self the `Toast` instance\n */\nfunction hideToast(self) {\n  const { element, options } = self;\n  addClass(element, showingClass);\n\n  if (options.animation) {\n    reflow(element);\n    emulateTransitionEnd(element, () => hideToastComplete(self));\n  } else {\n    hideToastComplete(self);\n  }\n}\n\n/**\n * Executes before showing the toast.\n * @param {Toast} self the `Toast` instance\n */\nfunction showToast(self) {\n  const { element, options } = self;\n  Timer.set(element, () => {\n    removeClass(element, hideClass); // B/C\n    reflow(element);\n    addClass(element, showClass);\n    addClass(element, showingClass);\n\n    if (options.animation) {\n      emulateTransitionEnd(element, () => showToastComplete(self));\n    } else {\n      showToastComplete(self);\n    }\n  }, 17, showingClass);\n}\n\n/**\n * Toggles on/off the `click` event listener.\n * @param {Toast} self the `Toast` instance\n * @param {boolean=} add when `true`, it will add the listener\n */\nfunction toggleToastHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  const {\n    element, triggers, dismiss, options,\n  } = self;\n\n  /* istanbul ignore else */\n  if (dismiss) {\n    action(dismiss, mouseclickEvent, self.hide);\n  }\n\n  /* istanbul ignore else */\n  if (options.autohide) {\n    [focusinEvent, focusoutEvent, mouseenterEvent, mouseleaveEvent]\n      .forEach((e) => action(element, e, interactiveToastHandler));\n  }\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach((btn) => action(btn, mouseclickEvent, toastClickHandler));\n  }\n}\n\n// TOAST EVENT HANDLERS\n// ====================\n/**\n * Executes after the instance has been disposed.\n * @param {Toast} self the `Toast` instance\n */\nfunction completeDisposeToast(self) {\n  Timer.clear(self.element, toastString);\n  toggleToastHandlers(self);\n}\n\n/**\n * Handles the `click` event listener for toast.\n * @param {MouseEvent} e the `Event` object\n */\nfunction toastClickHandler(e) {\n  const { target } = e;\n\n  const trigger = target && closest(target, toastToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getToastInstance(element);\n\n  /* istanbul ignore else */\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n  self.relatedTarget = trigger;\n  self.show();\n}\n\n/**\n * Executes when user interacts with the toast without closing it,\n * usually by hovering or focusing it.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Toast` instance\n */\nfunction interactiveToastHandler(e) {\n  const element = this;\n  const self = getToastInstance(element);\n  const { type, relatedTarget } = e;\n\n  /* istanbul ignore next: a solid filter is required */\n  if (!self || (element === relatedTarget || element.contains(relatedTarget))) return;\n\n  if ([mouseenterEvent, focusinEvent].includes(type)) {\n    Timer.clear(element, toastString);\n  } else {\n    Timer.set(element, () => self.hide(), self.options.delay, toastString);\n  }\n}\n\n// TOAST DEFINITION\n// ================\n/** Creates a new `Toast` instance. */\nclass Toast extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target `.toast` element\n   * @param {BSN.Options.Toast=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n    const { element, options } = self;\n\n    // set fadeClass, the options.animation will override the markup\n    if (options.animation && !hasClass(element, fadeClass)) addClass(element, fadeClass);\n    else if (!options.animation && hasClass(element, fadeClass)) removeClass(element, fadeClass);\n\n    // dismiss button\n    /** @type {HTMLElement?} */\n    self.dismiss = querySelector(toastDismissSelector, element);\n\n    // toast can have multiple triggering elements\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(toastToggleSelector, getDocument(element))]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // bind\n    self.show = self.show.bind(self);\n    self.hide = self.hide.bind(self);\n\n    // add event listener\n    toggleToastHandlers(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */  \n  get name() { return toastComponent; }\n  /**\n   * Returns component default options.\n   */  \n  get defaults() { return toastDefaults; }\n  /* eslint-enable */\n\n  /**\n   * Returns *true* when toast is visible.\n   */\n  get isShown() { return hasClass(this.element, showClass); }\n\n  // TOAST PUBLIC METHODS\n  // ====================\n  /** Shows the toast. */\n  show() {\n    const self = this;\n    const { element, isShown } = self;\n\n    /* istanbul ignore else */\n    if (element && !isShown) {\n      dispatchEvent(element, showToastEvent);\n      if (showToastEvent.defaultPrevented) return;\n\n      showToast(self);\n    }\n  }\n\n  /** Hides the toast. */\n  hide() {\n    const self = this;\n    const { element, isShown } = self;\n\n    /* istanbul ignore else */\n    if (element && isShown) {\n      dispatchEvent(element, hideToastEvent);\n      if (hideToastEvent.defaultPrevented) return;\n      hideToast(self);\n    }\n  }\n\n  /** Removes the `Toast` component from the target element. */\n  dispose() {\n    const self = this;\n    const { element, isShown } = self;\n\n    /* istanbul ignore else */\n    if (isShown) {\n      removeClass(element, showClass);\n    }\n\n    completeDisposeToast(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Toast, {\n  selector: toastSelector,\n  init: toastInitCallback,\n  getInstance: getToastInstance,\n});\n\n/**\n * Check if element matches a CSS selector.\n *\n * @param {HTMLElement} target\n * @param {string} selector\n * @returns {boolean}\n */\nfunction matches(target, selector) {\n  return target.matches(selector);\n}\n\n/** @type {Record<string, any>} */\nconst componentsList = {\n  Alert,\n  Button,\n  Carousel,\n  Collapse,\n  Dropdown,\n  Modal,\n  Offcanvas,\n  Popover,\n  ScrollSpy,\n  Tab,\n  Toast,\n  Tooltip,\n};\n\n/**\n * Initialize all matched `Element`s for one component.\n * @param {BSN.InitCallback<any>} callback\n * @param {NodeList | Node[]} collection\n */\nfunction initComponentDataAPI(callback, collection) {\n  [...collection].forEach((x) => callback(x));\n}\n\n/**\n * Remove one component from a target container element or all in the page.\n * @param {string} component the component name\n * @param {ParentNode} context parent `Node`\n */\nfunction removeComponentDataAPI(component, context) {\n  const compData = Data.getAllFor(component);\n\n  if (compData) {\n    [...compData].forEach((x) => {\n      const [element, instance] = x;\n      if (context.contains(element)) instance.dispose();\n    });\n  }\n}\n\n/**\n * Initialize all BSN components for a target container.\n * @param {ParentNode=} context parent `Node`\n */\nfunction initCallback(context) {\n  const lookUp = context && context.nodeName ? context : document;\n  const elemCollection = [...getElementsByTagName('*', lookUp)];\n\n  ObjectKeys(componentsList).forEach((comp) => {\n    const { init, selector } = componentsList[comp];\n    initComponentDataAPI(init, elemCollection.filter((item) => matches(item, selector)));\n  });\n}\n\n/**\n * Remove all BSN components for a target container.\n * @param {ParentNode=} context parent `Node`\n */\nfunction removeDataAPI(context) {\n  const lookUp = context && context.nodeName ? context : document;\n\n  ObjectKeys(componentsList).forEach((comp) => {\n    removeComponentDataAPI(comp, lookUp);\n  });\n}\n\n// bulk initialize all components\nif (document.body) initCallback();\nelse {\n  addListener(document, 'DOMContentLoaded', () => initCallback(), { once: true });\n}\n\nconst BSN = {\n  Alert,\n  Button,\n  Carousel,\n  Collapse,\n  Dropdown,\n  Modal,\n  Offcanvas,\n  Popover,\n  ScrollSpy,\n  Tab,\n  Toast,\n  Tooltip,\n\n  initCallback,\n  removeDataAPI,\n  Version,\n  EventListener: Listener,\n};\n\nexport { BSN as default };\n","import BSN from 'bootstrap.native';\nimport Notiflix from 'notiflix';\nimport { Notify } from 'notiflix/build/notiflix-notify-aio';\n\nconst refs = {\n  modal: document.querySelector('#exampleModal'),\n  primBtn: document.querySelector('#prim-btn'),\n};\n\nconst modal = new BSN.Modal('#exampleModal');\n\nconst PROMPT_DELAY = 2000;\nconst MAX_PROMPT_ATTEMPTS = 4;\n\nlet promptCounter = 0;\nlet hasSubacribed = false;\n\ntimeoutForModal();\n\nrefs.modal.addEventListener('hide.bs.modal', timeoutForModal);\n\nrefs.primBtn.addEventListener('click', onSubacribeBtnClick);\n\nfunction timeoutForModal() {\n  setTimeout(() => {\n    if (promptCounter === MAX_PROMPT_ATTEMPTS || hasSubacribed) {\n      return;\n    }\n    modal.show();\n    promptCounter += 1;\n  }, PROMPT_DELAY);\n}\n\nfunction onSubacribeBtnClick() {\n  hasSubacribed = true;\n  modal.hide();\n  setTimeout(() => {\n    Notiflix.Notify.success('✅ thanks for subscribing!');\n  }, 500);\n}\n"],"names":["$f76f27f955386acd$var$EventRegistry","$f76f27f955386acd$var$globalListener","e","that","this","type","forEach","elementsMap","element","listenersMap","listenerMap","listener","options","apply","once","$f76f27f955386acd$var$removeListener","$f76f27f955386acd$var$addListener","eventType","Map","oneEventMap","has","set","oneElementMap","get","size","addEventListener","savedOptions","eventOptions","undefined","delete","removeEventListener","$f76f27f955386acd$var$Listener","on","off","registry","$f76f27f955386acd$var$getElementStyle","property","computedStyle","getComputedStyle","includes","getPropertyValue","$f76f27f955386acd$var$getElementTransitionDuration","propertyValue","durationValue","durationScale","duration","parseFloat","Number","isNaN","$f76f27f955386acd$var$dispatchEvent","event","dispatchEvent","$f76f27f955386acd$var$emulateTransitionEnd","handler","called","endEvent","Event","delay","delayValue","delayScale","$f76f27f955386acd$var$getElementTransitionDelay","transitionEndWrapper","target","setTimeout","$f76f27f955386acd$var$isNode","some","x","nodeType","$f76f27f955386acd$var$isWindow","object","constructor","name","$f76f27f955386acd$var$isDocument","$f76f27f955386acd$var$getDocument","node","ownerDocument","document","window","$f76f27f955386acd$var$querySelector","selector","parent","querySelector","$f76f27f955386acd$var$closest","closest","getRootNode","host","$f76f27f955386acd$var$ObjectAssign","obj","source","Object","assign","$f76f27f955386acd$var$hasClass","classNAME","classList","contains","$f76f27f955386acd$var$removeClass","remove","$f76f27f955386acd$var$isHTMLElement","$f76f27f955386acd$var$componentData","$f76f27f955386acd$var$Data","component","instance","getAllFor","allForC","instanceMap","$f76f27f955386acd$var$getInstance","$f76f27f955386acd$var$OriginalEvent","EventType","config","OriginalCustomEvent","CustomEvent","cancelable","bubbles","$f76f27f955386acd$var$getAttribute","attribute","getAttribute","$f76f27f955386acd$var$normalizeValue","value","$f76f27f955386acd$var$ObjectKeys","keys","$f76f27f955386acd$var$toLowerCase","toLowerCase","$f76f27f955386acd$var$BaseComponent","version","defaults","dispose","self","prop","Error","prevInstance","length","defaultOps","inputOps","ns","data","dataset","normalOps","dataOps","title","k","key","replace","match","$f76f27f955386acd$var$normalizeOptions","$f76f27f955386acd$var$getAlertInstance","$f76f27f955386acd$var$closeAlertEvent","$f76f27f955386acd$var$closedAlertEvent","$f76f27f955386acd$var$alertTransitionEnd","$f76f27f955386acd$var$toggleAlertHandler","add","action","dismiss","close","$f76f27f955386acd$var$Alert","defaultPrevented","super","init","getInstance","$f76f27f955386acd$var$setAttribute","setAttribute","$f76f27f955386acd$var$addClass","$f76f27f955386acd$var$getButtonInstance","$f76f27f955386acd$var$toggleButtonHandler","toggle","$f76f27f955386acd$var$Button","preventDefault","isActive","$f76f27f955386acd$var$mouseenterEvent","$f76f27f955386acd$var$mouseleaveEvent","$f76f27f955386acd$var$getBoundingClientRect","includeScale","width","height","top","right","bottom","left","getBoundingClientRect","scaleX","scaleY","offsetWidth","offsetHeight","Math","round","y","$f76f27f955386acd$var$getDocumentElement","documentElement","$f76f27f955386acd$var$isElementInScrollRange","clientHeight","$f76f27f955386acd$var$isRTL","dir","$f76f27f955386acd$var$querySelectorAll","querySelectorAll","$f76f27f955386acd$var$getElementsByClassName","getElementsByClassName","$f76f27f955386acd$var$TimeCache","$f76f27f955386acd$var$Timer","callback","keyTimers","clearTimeout","$f76f27f955386acd$var$reflow","$f76f27f955386acd$var$passiveHandler","passive","$f76f27f955386acd$var$getTargetElement","targetAttr","doc","map","att","attValue","filter","$f76f27f955386acd$var$carouselDefaults","pause","keyboard","touch","interval","$f76f27f955386acd$var$getCarouselInstance","$f76f27f955386acd$var$startX","$f76f27f955386acd$var$currentX","$f76f27f955386acd$var$endX","$f76f27f955386acd$var$carouselSlideEvent","$f76f27f955386acd$var$carouselSlidEvent","$f76f27f955386acd$var$carouselPauseHandler","isPaused","$f76f27f955386acd$var$carouselResumeHandler","cycle","$f76f27f955386acd$var$carouselIndicatorHandler","indicator","isAnimating","newIndex","to","$f76f27f955386acd$var$carouselControlsHandler","control","orientation","next","prev","$f76f27f955386acd$var$carouselKeyHandler","code","test","tagName","RTL","arrowKeyNext","$f76f27f955386acd$var$carouselPointerDownHandler","controls","indicators","el","isTouch","pageX","$f76f27f955386acd$var$toggleCarouselTouchHandlers","$f76f27f955386acd$var$carouselPointerMoveHandler","$f76f27f955386acd$var$carouselPointerUpHandler","c","find","i","index","getSelection","toString","abs","$f76f27f955386acd$var$activateCarouselIndicator","pageIndex","$f76f27f955386acd$var$toggleCarouselHandlers","slides","arrow","$f76f27f955386acd$var$getActiveIndex","activeItem","indexOf","$f76f27f955386acd$var$Carousel","idx","direction","directionClass","eventProperties","relatedTarget","from","hidden","$f76f27f955386acd$var$carouselTransitionEndHandler","itemClasses","slide","id","$f76f27f955386acd$var$setElementStyle","styles","entries","style","setProperty","propObject","$f76f27f955386acd$var$collapseDefaults","$f76f27f955386acd$var$getCollapseInstance","$f76f27f955386acd$var$showCollapseEvent","$f76f27f955386acd$var$shownCollapseEvent","$f76f27f955386acd$var$hideCollapseEvent","$f76f27f955386acd$var$hiddenCollapseEvent","$f76f27f955386acd$var$collapseContent","triggers","scrollHeight","btn","$f76f27f955386acd$var$toggleCollapseHandler","$f76f27f955386acd$var$collapseClickHandler","trigger","$f76f27f955386acd$var$Collapse","hide","show","activeCollapse","activeCollapseInstance","$f76f27f955386acd$var$expandCollapse","$f76f27f955386acd$var$scrollEvent","$f76f27f955386acd$var$resizeEvent","$f76f27f955386acd$var$keyArrowUp","$f76f27f955386acd$var$keyArrowDown","$f76f27f955386acd$var$hasAttribute","hasAttribute","$f76f27f955386acd$var$focus","focus","$f76f27f955386acd$var$getWindow","defaultView","$f76f27f955386acd$var$dropdownMenuClasses","$f76f27f955386acd$var$isEmptyAnchor","parentAnchor","href","slice","$f76f27f955386acd$var$dropdownString","$f76f27f955386acd$var$dropupString","$f76f27f955386acd$var$dropstartString","$f76f27f955386acd$var$dropendString","$f76f27f955386acd$var$dropdownSelector","$f76f27f955386acd$var$getDropdownInstance","$f76f27f955386acd$var$verticalClass","$f76f27f955386acd$var$horizontalClass","$f76f27f955386acd$var$menuFocusTags","$f76f27f955386acd$var$dropdownDefaults","offset","display","$f76f27f955386acd$var$showDropdownEvent","$f76f27f955386acd$var$shownDropdownEvent","$f76f27f955386acd$var$hideDropdownEvent","$f76f27f955386acd$var$hiddenDropdownEvent","$f76f27f955386acd$var$styleDropdown","menu","parentElement","menuEnd","p","positionClass","dropdownMargin","dropdown","dropup","dropstart","dropend","dropdownPosition","menuStart","menuWidth","menuHeight","clientWidth","targetLeft","targetTop","targetWidth","targetHeight","leftFullExceed","rightFullExceed","bottomExceed","bottomFullExceed","topExceed","leftExceed","rightExceed","posAjust","margin","join","$f76f27f955386acd$var$toggleDropdownDismiss","open","$f76f27f955386acd$var$dropdownDismissHandler","$f76f27f955386acd$var$dropdownPreventScroll","$f76f27f955386acd$var$dropdownKeyHandler","ev","$f76f27f955386acd$var$dropdownLayoutHandler","$f76f27f955386acd$var$toggleDropdownHandler","$f76f27f955386acd$var$dropdownClickHandler","$f76f27f955386acd$var$getCurrentOpenDropdown","currentParent","children","hasData","isForm","activeElement","menuItems","firstElementChild","$f76f27f955386acd$var$getMenuItems","$f76f27f955386acd$var$Dropdown","currentElement","currentInstance","$f76f27f955386acd$var$removeAttribute","removeAttribute","$f76f27f955386acd$var$getDocumentBody","body","$f76f27f955386acd$var$isShadowRoot","$f76f27f955386acd$var$isTableElement","$f76f27f955386acd$var$getElementContainer","getOffset","majorBlockTags","offsetParent","win","containers","parentNode","nodeName","assignedSlot","shadowRoot","push","every","r","$f76f27f955386acd$var$stickyTopClass","$f76f27f955386acd$var$positionStickyClass","$f76f27f955386acd$var$getFixedItems","$f76f27f955386acd$var$measureScrollbar","innerWidth","$f76f27f955386acd$var$setScrollbar","overflow","bd","bodyPad","parseInt","sbWidth","fixedItems","paddingRight","fixed","itemPadValue","itemMValue","marginRight","$f76f27f955386acd$var$createElement","param","createElement","attr","newElement","$f76f27f955386acd$var$modalBackdropClass","$f76f27f955386acd$var$offcanvasBackdropClass","$f76f27f955386acd$var$overlay","$f76f27f955386acd$var$getCurrentOpen","$f76f27f955386acd$var$toggleOverlayType","isModal","targetClass","$f76f27f955386acd$var$appendOverlay","container","hasFade","append","$f76f27f955386acd$var$showOverlay","$f76f27f955386acd$var$hideOverlay","$f76f27f955386acd$var$removeOverlay","$f76f27f955386acd$var$resetScrollbar","$f76f27f955386acd$var$isVisible","$f76f27f955386acd$var$modalDefaults","backdrop","$f76f27f955386acd$var$getModalInstance","$f76f27f955386acd$var$showModalEvent","$f76f27f955386acd$var$shownModalEvent","$f76f27f955386acd$var$hideModalEvent","$f76f27f955386acd$var$hiddenModalEvent","$f76f27f955386acd$var$setModalScrollbar","scrollbarWidth","modalHeight","modalScrollHeight","modalOverflow","padStyle","$f76f27f955386acd$var$toggleModalDismiss","$f76f27f955386acd$var$modalDismissHandler","update","$f76f27f955386acd$var$modalKeyHandler","$f76f27f955386acd$var$toggleModalHandler","$f76f27f955386acd$var$modalClickHandler","$f76f27f955386acd$var$afterModalHide","focusElement","$f76f27f955386acd$var$afterModalShow","$f76f27f955386acd$var$beforeModalShow","$f76f27f955386acd$var$beforeModalHide","isStatic","modalDialog","selectedText","targetInsideDialog","$f76f27f955386acd$var$staticTransitionEnd","$f76f27f955386acd$var$Modal","overlayDelay","currentOpen","bind","$f76f27f955386acd$var$offcanvasDefaults","scroll","$f76f27f955386acd$var$getOffcanvasInstance","$f76f27f955386acd$var$showOffcanvasEvent","$f76f27f955386acd$var$shownOffcanvasEvent","$f76f27f955386acd$var$hideOffcanvasEvent","$f76f27f955386acd$var$hiddenOffcanvasEvent","$f76f27f955386acd$var$toggleOffcanvasEvents","$f76f27f955386acd$var$offcanvasTriggerHandler","$f76f27f955386acd$var$toggleOffCanvasDismiss","$f76f27f955386acd$var$offcanvasKeyDismissHandler","$f76f27f955386acd$var$offcanvasDismissHandler","$f76f27f955386acd$var$beforeOffcanvasShow","$f76f27f955386acd$var$setOffCanvasScrollbar","visibility","$f76f27f955386acd$var$showOffcanvasComplete","$f76f27f955386acd$var$beforeOffcanvasHide","blur","$f76f27f955386acd$var$hideOffcanvasComplete","offCanvasDismiss","selection","visibleTrigger","$f76f27f955386acd$var$Offcanvas","$f76f27f955386acd$var$getTipTemplate","tipType","isTooltip","$f76f27f955386acd$var$isMedia","s","$f76f27f955386acd$var$getRectRelativeToOffsetParent","isParentAnElement","rect","$f76f27f955386acd$var$isScaledElement","offsets","offsetRect","clientLeft","clientTop","$f76f27f955386acd$var$tipClassPositions","$f76f27f955386acd$var$styleTip","tooltip","tipPositions","isPopover","tipWidth","tipHeight","htmlcw","htmlch","placement","parentLeft","parentRight","parentTop","parentCWidth","parentOWidth","parentPosition","fixedParent","staticParent","isSticky","leftBoundry","rightBoundry","elemWidth","elemHeight","elemRectLeft","elemRectRight","elemRectTop","isWin","scrollX","scrollLeft","scrollY","scrollTop","$f76f27f955386acd$var$getNodeScroll","topPosition","leftPosition","rightPosition","arrowTop","arrowLeft","arrowRight","arrowWidth","arrowHeight","arrowAdjust","horizontal","vertical","className","eX","eY","pageY","clientX","clientY","$f76f27f955386acd$var$tooltipDefaults","template","customClass","sanitizeFn","animation","$f76f27f955386acd$var$focusinEvent","$f76f27f955386acd$var$focusoutEvent","$f76f27f955386acd$var$elementUID","$f76f27f955386acd$var$elementMapUID","$f76f27f955386acd$var$elementIDMap","$f76f27f955386acd$var$getUID","result","elID","elMap","elkey","$f76f27f955386acd$var$isFunction","fn","userAgentData","$f76f27f955386acd$var$uaDATA","navigator","$f76f27f955386acd$var$userAgentData","userAgent","$f76f27f955386acd$var$userAgentString","$f76f27f955386acd$var$userAgent","$f76f27f955386acd$var$appleBrands","$f76f27f955386acd$var$isApple","brands","brand","$f76f27f955386acd$var$isString","str","$f76f27f955386acd$var$setHtml","content","arr","dirty","trim","tempDocument","DOMParser","parseFromString","childNodes","Array","isArray","$f76f27f955386acd$var$isVisibleTip","tip","$f76f27f955386acd$var$getTooltipInstance","$f76f27f955386acd$var$toggleTooltipAction","handleTouch","$f76f27f955386acd$var$tooltipShownAction","shownTooltipEvent","$f76f27f955386acd$var$tooltipHiddenAction","hiddenTooltipEvent","$f76f27f955386acd$var$removeTooltip","$f76f27f955386acd$var$toggleTooltipHandlers","dismissible","enabled","triggerOptions","split","elemIsMedia","tr","$f76f27f955386acd$var$toggleTooltipOpenHandlers","parentModal","parentOffcanvas","scrollTarget","$f76f27f955386acd$var$toggleTooltipTitle","titleAtt","$f76f27f955386acd$var$Tooltip","outTimer","showTooltipEvent","hideTooltipEvent","enable","disable","toggleEnabled","$f76f27f955386acd$var$disposeTooltipComplete","tipString","tipComponent","elem","idealContainer","btnClose","titleParts","contentParts","placementClass","tooltipTemplate","htmlMarkup","firstChild","cloneNode","bodyClass","tooltipHeader","tooltipBody","tempTitle","tempContent","tempBtn","$f76f27f955386acd$var$createTip","$f76f27f955386acd$var$popoverDefaults","$f76f27f955386acd$var$Popover","$f76f27f955386acd$var$getElementsByTagName","getElementsByTagName","$f76f27f955386acd$var$scrollspyDefaults","$f76f27f955386acd$var$activateScrollSpy","$f76f27f955386acd$var$updateSpyTargets","itemsLength","links","scrollHEIGHT","$f76f27f955386acd$var$getScrollHeight","targetItem","items","maxScroll","innerHeight","$f76f27f955386acd$var$getOffsetHeight","link","charAt","offsetTop","$f76f27f955386acd$var$clear","item","$f76f27f955386acd$var$activate","parents","parentItem","menuItem","parentLink","previousElementSibling","$f76f27f955386acd$var$toggleSpyHandlers","refresh","$f76f27f955386acd$var$ScrollSpy","newActiveItem","$f76f27f955386acd$var$getTabInstance","$f76f27f955386acd$var$showTabEvent","$f76f27f955386acd$var$shownTabEvent","$f76f27f955386acd$var$hideTabEvent","$f76f27f955386acd$var$hiddenTabEvent","$f76f27f955386acd$var$tabPrivate","$f76f27f955386acd$var$triggerTabEnd","tabContent","nav","$f76f27f955386acd$var$triggerTabShow","nextContent","tab","currentHeight","nextHeight","$f76f27f955386acd$var$triggerTabHide","$f76f27f955386acd$var$getActiveTab","activeTabs","$f76f27f955386acd$var$getParentDropdown","$f76f27f955386acd$var$toggleTabHandler","$f76f27f955386acd$var$tabClickHandler","$f76f27f955386acd$var$Tab","activeDropdown","toggleTab","firstTab","firstTabContent","$f76f27f955386acd$var$toastDefaults","autohide","$f76f27f955386acd$var$getToastInstance","$f76f27f955386acd$var$showToastEvent","$f76f27f955386acd$var$shownToastEvent","$f76f27f955386acd$var$hideToastEvent","$f76f27f955386acd$var$hiddenToastEvent","$f76f27f955386acd$var$showToastComplete","$f76f27f955386acd$var$hideToastComplete","$f76f27f955386acd$var$toggleToastHandlers","$f76f27f955386acd$var$interactiveToastHandler","$f76f27f955386acd$var$toastClickHandler","$f76f27f955386acd$var$Toast","isShown","$f76f27f955386acd$var$showToast","$f76f27f955386acd$var$hideToast","$f76f27f955386acd$var$completeDisposeToast","$f76f27f955386acd$var$componentsList","$f76f27f955386acd$var$initCallback","context","elemCollection","comp","collection","matches","$f76f27f955386acd$var$matches","$f76f27f955386acd$export$2e2bcd8739ae039","lookUp","compData","$f76f27f955386acd$var$removeComponentDataAPI","EventListener","$3a9f706fda0e48f1$var$refs","modal","primBtn","$3a9f706fda0e48f1$var$modal","Modal","$3a9f706fda0e48f1$var$promptCounter","$3a9f706fda0e48f1$var$hasSubacribed","$3a9f706fda0e48f1$var$timeoutForModal","$parcel$interopDefault","$eWCmQ","Notify","success"],"version":3,"file":"17-modal-spam.280810b5.js.map"}